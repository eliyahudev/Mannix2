#!/usr/local/bin/perl


use POSIX qw(ceil floor);
use Data::Dumper qw(Dumper);
use Switch;

sub usage {
    my $help = <<EOM;

    gen_regfile_hdl Version $version

      Usage:

        $0  [various parameters...]  <EXCEL_EXPORT_FILE>

        where  EXCEL_EXPORT_FILE    is Input Text file name generated by Excell. (Mandatory)

        The various parameters needed are:

        -h                   Show help info.
        -module=<MODULE>     MODULE  is the module name as it appears in the first coloum.
        the default is the first one that listed in EXCEL_EXPORT_FILE.
        -base_address_name=<BASE_ADDRESS_NAME>     BASE_ADDRESS_NAME is the name of the base addressthat should be taken from the address map file.
        -type=<TYPE>         TYPE    is cs_r_wn  for architecture with CS + R_WN     (default)
        EXCEL_FILEor rd_wr_en for architecture with RD_EN + WR_EN
        -clock=<CLOCK>       CLOCK   is the name of the clock signal. default is clk.
        -reset=<RESET>       RESET   is the name fo the active low reset signal. default is reset_n.
        -cs=<CS>             CS      is the name of the Chip select signal. default is hcs.
        -r_wn=<R_WN>         R_WN    is the name of the Read/Write_not signal. default is h_r_wn.
        -rd_en=<RD_EN>       RD_EN   is the name of the read enable signal. default is hrd.
        -wr_en=<WR_EN>       WR_EN   is the name of the write enable signal. default is hwr.
        -address=<ADDRESS>   ADDRESS is the name of the address bus. default is h_addr
        -aw=<AW>             AW      is the width of the address bus. default is 16  (integer).
        -wr_pulse_out=<0|1>  0|1     is the condition for outputting wr_pulse. default is 0  (integer).
        -shift_addr=<SHIFT>  SHIFT   is how much shift right should be done on ADDRESS. default is 2 (integer).
        -data=<DATA>         DATA    is the name of the data bus. default is h_data.
        -dat_out=<DOUT>      DOUT    is the name of the output data bus. default is dat_out.
        -ack_out=<ACK>       ACK     is the name of the acknowledge output signal. default is ack_out.
        -dw=<DW>             DW      is the width of the data bus. default is 32  (integer).
        -mips_test           generate registers test in MIPS assembler
        -host_test           generate registers test in host commands
        -dut=<MODULE_FILE>   MODULE_FILE is the path and file name of the dut top module
        -intc_name=<INTC_NAME> INTC_NAME is the interupt controler name prefix. the scripts will look for *<INTC_NAME>_MASK register with GUI type
        -intc_name2=<INTC_NAME> INTC_NAME is the interupt controler name prefix. the scripts will look for *<INTC_NAME>_MASK register with GUI type
        -rd_wr_intc_name               which intc is for illegal read and writes from host
        -cdc                           controls if there is more than one clock domain
        -sw_headers_path     is a pointer to the folder of S/W register files headers

Description:
        This script will generate the Write/Read Verilog portion of the
        programming model register file.

EOM

        print $help;
}


sub get_options {
    my $arg ;
    $opt{extra_space} = 0;
    while (@_) {
        $arg = shift ;
        $arg =~ /^-h$/ && do { &usage; exit 1;};
        $arg =~ /-type=/ && do {$arg =~ s/-type=(\w+)/$1/s;             $opt{type}=$arg; next};
        $arg =~ /-module=/ && do {$arg =~ s/-module=(\w+)/$1/s;         $opt{module_name}=$arg; next};
        $arg =~ /-clock=/ && do {$arg =~ s/-clock=(\w+)/$1/s;           $opt{clock}=$arg; next};
        $arg =~ /-reset=/ && do {$arg =~ s/-reset=(\w+)/$1/s;           $opt{reset}=$arg; next};
        $arg =~ /-cs=/ && do {$arg =~ s/-cs=(\w+)/$1/s;                 $opt{cs}=$arg; next};
        $arg =~ /-r_wn=/ && do {$arg =~ s/-r_wn=(\w+)/$1/s;             $opt{r_wn}=$arg; next};
        $arg =~ /-rd_en=/ && do {$arg =~ s/-rd_en=(\w+)/$1/s;           $opt{rd_en}=$arg; next};
        $arg =~ /-wr_en=/ && do {$arg =~ s/-wr_en=(\w+)/$1/s;           $opt{wr_en}=$arg; next};
        $arg =~ /-address=/ && do {$arg =~ s/-address=(\w+)/$1/s;       $opt{address}=$arg; next};
        $arg =~ /-address_map_file=/ && do {$arg =~ s/-address_map_file=([\w\/]+)/$1/s;       $opt{address_map_file}=$arg; next};
        $arg =~ /-phy_number=/ && do {$arg =~ s/-phy_number=(\d+)/$1/s; $opt{phy_number}=$arg; next};
        $arg =~ /-aw=/ && do {$arg =~ s/-aw=(\d+)/$1/s;                 $opt{aw}=$arg; next};
        $arg =~ /-wr_pulse_out=/ && do {$arg =~ s/-wr_pulse_out=(\d+)/$1/s; $opt{wr_pulse_out}=$arg; next};
        $arg =~ /-shift_addr=/ && do {$arg =~ s/-shift_addr=(\d+)/$1/s; $opt{shift_a}=$arg; next};
        $arg =~ /-data=/ && do {$arg =~ s/-data=(\w+)/$1/s;             $opt{data}=$arg; next};
        $arg =~ /-dat_out=/ && do {$arg =~ s/-dat_out=(\w+)/$1/s;       $opt{dat_out}=$arg; next};
        $arg =~ /-ack_out=/ && do {$arg =~ s/-ack_out=(\w+)/$1/s;       $opt{ack_out}=$arg; next};
        $arg =~ /-dw=/ && do {$arg =~ s/-dw=(\d+)/$1/s;                 $opt{dw}=$arg; next};
        $arg =~ /-mips_test/ && do {                                    $opt{gen_test}= 1; $opt{mips_test}= 1; next};
        $arg =~ /-host_test/ && do {                                    $opt{gen_test}= 1; $opt{host_test}= 1; next};
        $arg =~ /-dut=/ && do {$arg =~ s/-dut=(\w+)/$1/s;               $opt{dut}=$arg; next};
        $arg =~ /-intc_name=/ && do {$arg =~ s/-intc_name=(\w+)/$1/s;   $opt{intc_name}=$arg; next};
        $arg =~ /-intc_name2=/ && do {$arg =~ s/-intc_name2=(\w+)/$1/s; $opt{intc_name2}=$arg; next};
        $arg =~ /-intc_name3=/ && do {$arg =~ s/-intc_name3=(\w+)/$1/s; $opt{intc_name3}=$arg; next};
        $arg =~ /-intc_name4=/ && do {$arg =~ s/-intc_name4=(\w+)/$1/s; $opt{intc_name4}=$arg; next};
        $arg =~ /-intc_clk_name=/ && do {$arg =~ s/-intc_clk_name=(\w+)/$1/s; $opt{intc_clk_name}=$arg; next};
        $arg =~ /-multy_int=/ && do {$arg =~ s/-multy_int=(\w+)/$1/s; $opt{multy_int}=$arg; next};
        $arg =~ /-rd_wr_intc_name=/ && do {$arg =~ s/-rd_wr_intc_name=(\w+)/$1/s;   $opt{rd_wr_intc_name}=$arg; next};
        $arg =~ /-cdc=/ && do {$arg =~ s/-cdc=(\w+)/$1/s;             $opt{cdc}=$arg; next};
        $arg =~ /-base_address_name=/ && do {$arg =~ s/-base_address_name=(\w+)/$1/s;       $opt{base_address_name}=$arg; next};
        $arg =~ /-sw_headers_path=/ && do {$arg =~ s/-sw_headers_path=([\w\/]+)/$1/s;       $opt{sw_headers_path}=$arg; next};
        (($arg !~ /-/ )&&($arg =~ /\w+/)) && do { $opt{ExcelExportFile}=$arg ; next};
    }
    die ("No file_name specified\nType $0 -h to get help\n\n") unless ($opt{ExcelExportFile});
}



########################
#                      #
#  Program Starts Here #
#                      #
########################
$|=1;                           # immediate output

use vars qw( %opt );
use POSIX ;

$version = "1.00a";

if ( $#ARGV < 0) {               # In perl language the first parameter index is 0
    printf("No Excel Export file was given !!!\n");
    printf("Invoke with:  gen_regfile_hdl -h for help.\n");
    exit 1;
}                               # Not enough parameters ends here

$opt{type}              = "cs_r_wn";
$opt{module_name}       = "XXX";
$opt{cdc}               = 0;
$opt{clock}             = "clk";
$opt{gclock}            = "gclk";
$opt{reset}             = "reset_n";
$opt{hreset}            = "hw_reset_n";
$opt{cs}                = "h_cs";
$opt{r_wn}              = "h_r_wn";
$opt{rd_en}             = "hrd";
$opt{wr_en}             = "hwr";
$opt{address}           = "h_addr";
$opt{address_map_file}  = "./address_map.txt";
$opt{base_address_name} = "UNDEFINED";
$opt{chip_name}         = $ENV{'PROJECT'};
$opt{aw}                = 8;
$opt{phy_number}        = 0;
$opt{wr_pulse_out}      = 0;
$opt{pulse_addr_ios}    = 0;
$opt{pulse_addr_inputs} = "";
$opt{pulse_addr_ports}  = "";
$opt{reset_ctrl}        = 0;
$opt{add_gclk_ins}      = 1;
$opt{shift_a}           = 2;
$opt{data}              = "h_data";
$opt{dw}                = 32;
$opt{dat_out}           = "dat_out";
$opt{ack_out}           = "ack_out";
$opt{ExcelExportFile}   ="UNDEFINED";
$opt{gen_test}          = 0;
$opt{mips_test}         = 0;
$opt{host_test}         = 0;
$opt{dut}               = "";
$opt{mem_file}          = "";
$opt{intc_name}         = "";
$opt{intc_name2}        = "";
$opt{intc_name3}        = "";
$opt{intc_name4}        = "";
$opt{intc_clk_name}     = "rf_clk";
$opt{rd_wr_intc_name}   = "irq_sig"; ###this was done for legacy reasons!!!!
$opt{multy_int}         = "";
$opt{sw_headers_path}   = "";

&get_options (@ARGV);           # fills global hash %opt

print "ADDRESS_MAPPING_TEXT_FILE = $opt{address_map_file}\n";
print "MODULE_NAME = $opt{module_name}\n";
print "RF_BASE_ADDRESS_NAME = $opt{base_address_name}\n";
print "INTC_CLK_NAME = $opt{intc_clk_name}\n";

my $mask_width = ceil($opt{dw}/4) ;
my $bitsize;
my $lsbit;
my $msbit;
#prev_msbits is used to decide whether resreved fields are needed in vr_ad definitions.
my $prev_msbits;
my @REGS ;                      # list of all regs
my %HADDRESSES ;                # each key is a reg name, each value is the address of that reg
my %IADDRESSES ;                # same as HADDRESSES, only masked
my %MAINNAME ;                  # Main name of GUI registers
my %AVOID_HOST ;
my %SIZES ;
my %LSBITS ;
my %MSBITS ;
my %RESET_VALS ;
my %DV_RESET_VALS ;
my %TYPES ;
my %MASKS_FIELDS ;
my %MASKS_REGS ;
my %INTC_INPUT;
my %INTC_NAME;
my %INTC_ON;
my %INTC_SIG;
my %INTC_BITSIZE;
my %INTC_MSBIT;
my %INTC_LSBIT;
my %SRST_OUTPUT;
my %SRST_SIG;
my %SRST_BITSIZE;
my %SRST_MSBIT;
my %SRST_LSBIT;

#my $cs_d ;
my $intc_tmp ;
my $tmp ;
my $tmp2 ;
my @TMP ;
my $t_module ;
my $t_reg ;
my $reg_number ;
my $t_haddress ;
my $t_iaddress ;
my $t_field ;
my $t_mask ;
my $t_type ;
my $t_reset ;
my $t_bitzise ;
my $t_msbit ;
my $t_lsbit ;
my $reg_dec_filename                            = "declarations.v" ;
my $rw_logic_filename                           = "read_write_logic.v";
my $intc_filename                               = "intc_logic.v";
my $address_map_filename_suffix                 = "_address_map.txt";
my $mips_test_def_file_suffix                   = "_mips_test_def.s";
my $mips_test_WR_RD_FF_file_suffix              = "_mips_test_WR_RD_FF.s";
my $specman_test_WR_RD_FF_file_suffix           = "_mips_test_WR_RD_FF.e";
my $specman_test_CNT_FF_file_suffix             = "_mips_test_CNT_FF.e";
my $specman_test_CHK_DEFAULTS_RD_FF_file_suffix = "_mips_test_CHK_DEFAULTS_FF.e";
my $mips_test_WRCNT_file_suffix                 = "_mips_test_WRCNT.s";
my $mips_test_RDCNT_file_suffix                 = "_mips_test_RDCNT.s";
my $register_size                               = 32;

my $host_test_def_file_suffix      = "_host_test_def.ini";
my $host_test_WR_RD_FF_file_suffix = "_host_test_WR_RD_FF.ini";
my $host_test_WRCNT_file_suffix    = "_host_test_WRCNT.ini";
my $host_test_RDCNT_file_suffix    = "_host_test_RDCNT.ini";

my $read_reset_value ;
my $expected_read_val ;
my $outputs_dec_filename    = "outputs_declare.v" ;
my $outputs_list_filename   = "outputs_list.v" ;
my $parameters_def_filename = "parameters_def.v" ;
my $writable_found ;
my $pulse_found ;
my $first_field ;
my $module_name_length ;
my $max_reg_length = 0 ;
my $max_field_length = 0;
my $reg_cnt_test_count ;
my $t_length ;
my $t_mask_length ;
my $max_reg_width;
my $header_file = "/home/users/syncmgr/templates/file_header";

my %PARAM = ();
my %MEMO  = ();
my @mem_name;
my @mem_width;
my @limit;
my $k     =0;
my $mem_arr_name   = "mem_core_array";

my @INTC;
my $intc_bitzise;
my $intc_msbit;
my $intc_lsbit;
my $intc_type;
my $t_clock_domain = "rf_clk";
my $intc_reset     = "hw_reset_n";

my @SRST;
my $srst_bitzise;
my $srst_msbit;
my $srst_lsbit;
my $srst_type;
my $srst_on       = 0;
my $t_mask_new    = 0;
my $t_mask_hex    = 0 ;
my $last_gui      = 0;

my $aw_trunc      = $opt{aw}-2;

${gclk_en_ored}   = "";
${pulse_addr}     = "";
${pre_pulse_addr} = "";

if ($opt{intc_clk_name} eq "cbus_rf_clk") { $opt{intc_clk_name} = "rf_clk"; }

if ($opt{intc_name} ne "") { push @INTC, $opt{intc_name}; }
if ($opt{intc_name2} ne "") { push @INTC, $opt{intc_name2}; }
if ($opt{intc_name3} ne "") { push @INTC, $opt{intc_name3}; }
if ($opt{intc_name4} ne "") { push @INTC, $opt{intc_name4}; }

push @SRST, "sreset_n";         # Remark this line to disable sreset logic

$synch_regs = 0;

open(EXCEL_FILE,$opt{ExcelExportFile})|| die "Could not open Excel export file $opt{ExcelExportFile}\n";
my @EE_LINES ;
@EE_LINES = <EXCEL_FILE> ;
for (@EE_LINES) {
    chop;
    @TMP      = split " ",$_ ;
    $t_module = @TMP[0] ;
    # do only if module name is as requested
    $t_reg    = @TMP[0] ;
    $t_length = length($t_reg);
    if ($t_length > $max_reg_length) { $max_reg_length = $t_length ; }
    $t_haddress   = @TMP[1] ;
    ($t_iaddress) = shlof_bitim($t_haddress,$opt{shift_a},16) ;
    $t_field      = lc(@TMP[2]) ;
    $t_length     = length($t_field);
    if ($t_length > $max_field_length) { $max_field_length = $t_length ; }
    $t_mask       = @TMP[4] ;
    $t_type       = @TMP[5] ;
    $t_reset      = @TMP[6] ;
    $t_False_path = @TMP[7];

    $t_signed     = @TMP[8];
    $async_reset  = @TMP[10];
    if($opt{cdc}) { $t_clock_domain = @TMP[11]; }


    my $intc_input = 0;
    my $intc_sig   = 0;
    my $intc_name  = "";
    foreach $t_intc (@INTC) {
        if ($t_field =~ ("_$t_intc\$")) {
            $intc_input = 1; $intc_name = $t_intc;
        }
        if ($t_field =~ ("_$t_intc"."_")) {
            $intc_sig = 1;   $intc_name = $t_intc;
        }
    }
    my $srst_output = 0;
    my $srst_sig = 0;
    foreach $t_srst (@SRST) {
        if (($t_field =~ ("_$t_srst\$")) && !($t_field =~ ("_warm_sreset"))) {
            $srst_output = 1; ##print "srst_output |$t_field|\n";
        }
        if (($t_field =~ ("_$t_srst"."_")) || ($t_field =~ ("_warm_sreset"))) {
            $srst_sig = 1; ## print "srst_sig |$t_field|\n";
        }
    }

    if ($t_type eq "GUI") {
        foreach $t_intc (@INTC) {
            my $t_intc_mask = $t_intc."_mask";
            if ($t_field =~ /$t_intc_mask/ ) {
                print (">> Note: Creating Intteruppt Controller |".$opt{module_name}."_$t_intc|\n");
                ($intc_bitzise,$intc_msbit,$intc_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB
                $INTC_ON{$t_intc}      = 1;
                $INTC_BITSIZE{$t_intc} = $intc_bitzise;
                $INTC_MSBIT{$t_intc}   = $intc_msbit;
                $INTC_LSBIT{$t_intc}   = $intc_lsbit;
            }
        }
        foreach $t_srst (@SRST) {
            my $t_srst_gui = $opt{module_name}."_".$t_srst;
            if ($t_field =~ /$t_srst_gui/ ) {
                print (">> Note: Creating SRESET Controller |$t_srst_gui|\n");
                ($srst_bitzise,$srst_msbit,$srst_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB
                $SRST_BITSIZE{$t_srst} = $srst_bitzise;
                $SRST_MSBIT{$t_srst}   = $srst_msbit;
                $SRST_LSBIT{$t_srst}   = $srst_lsbit;
                $srst_on               = 1;
                $opt{reset_ctrl}       = 1;
            }
        }
        $last_t_field = $t_field;
        $last_gui = 1;

    } else {
        # check if the register was defined before
        if (exists $HADDRESSES{$t_reg}) {
            # if reg was defined, then must add this field to the reg field list
            @TMP = @$t_reg ;
            push @TMP,$t_field ;
            @$t_reg = @TMP ;
        } else {
            # if reg was not defined before then define it
            $HADDRESSES{$t_reg} = $t_haddress ; # add reg address to HADDRESSES hash
            $IADDRESSES{$t_reg} = $t_iaddress ;
            if ($last_gui){
                $MAINNAME{$t_reg} = $last_t_field ;
            } else { $MAINNAME{$t_reg} = $t_field ; }
            $last_gui = 0;
            push @REGS,$t_reg ;       # add reg to REGS list
            @$t_reg = ($t_field);     # define the first field
        }
        { $AVOID_HOST{$t_reg} = 0; }

        # check if field was defined. I assume a field can only have one defenition
        if (not exists $TYPES{$t_field}) {
            # define this field
            $t_mask_length = length $t_mask;
            if ($t_mask_length  > $mask_width) {
                print ("WARNING: Field $t_field has mask wider than data bus width.\n");
            }
            $MASKS_FIELDS{$t_field}  = $t_mask ;
            if (($t_type eq "RW")|($t_type eq "RW_PULSE")) {
                $MASKS_REGS{$t_reg}  = sprintf "%.8lx",hex(lc(0x.$MASKS_REGS{$t_reg})) | hex(lc(0x.$t_mask)) ;
            }
            ($t_bitzise,$t_msbit,$t_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB

            $SIZES{$t_field}        = $t_bitzise ;
            $MSBITS{$t_field}       = $t_msbit ;
            $LSBITS{$t_field}       = $t_lsbit ;
            $TYPES{$t_field}        = $t_type ;
            $CLOCK_DOMAIN{$t_field} = $t_clock_domain;
            $SHADOW{$t_field}       = $t_shadow ;
            $SIGNED{$t_field}       = $t_signed ;
            $REG_NAME{$t_field}     = $t_field ;
            $ASYNC_RST{$t_field}    = $async_reset;
            $t_reset                =~ s/0x// ;

            # shift the mask to the lsb
            $t_mask_new = (hex($t_mask) >> $LSBITS{$t_field});
            $t_mask_hex = sprintf "%x", $t_mask_new;

            # Ronen Supports Negative Number: and with the mask register
            $RESET_VALS{$t_field}  = sprintf "%x", (hex(lc(0x.$t_reset)) & hex(lc(0x.$t_mask_hex)));
            $DV_RESET_VALS{$t_field}  = sprintf "%s", $t_reset;
        }

        $INTC_INPUT{$t_field}  = $intc_input;
        $INTC_SIG{$t_field}    = $intc_sig;
        $INTC_NAME{$t_field}   = $intc_name;
        $SRST_OUTPUT{$t_field} = $srst_output;
        $SRST_SIG{$t_field}    = $srst_sig;

        if (($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")){
            $synch_regs = 1;
            if (exists $different_clk_domain{$CLOCK_DOMAIN{$t_field}}){
                if (exists $reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}}){
                    if ($srst_output == 0) { $reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}} = 0; }
                }
            }
            else {
                $different_clk_domain{$CLOCK_DOMAIN{$t_field}} = $CLOCK_DOMAIN{$t_field};
                $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} = 0;
                if ($srst_output == 1) {$reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}} = 1; }
            }
            if ( $t_shadow eq "shadow"){
                $shadow_count_tmp = $shadow_count_domain{$CLOCK_DOMAIN{$t_field}};
                $shadow_field_name{$CLOCK_DOMAIN{$t_field}}{$shadow_count_tmp} = $t_field;
                $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} = $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} + 1;
            }
        }
    }
}


# ==========================================
# Creating verilog of reg declarations
open(REG_DEC_FILE, ">$reg_dec_filename") || die "Can't create reg_dec_file $reg_dec_filename\n";
open(IOS_DEC_FILE, ">$outputs_dec_filename") || die "Can't create outputs_dec_file $outputs_dec_filename\n";
open(PAR_DEF_FILE, ">$parameters_def_filename") || die "Can't create parameters_def_file $outputs_dec_filename\n";
open(IOS_LIST_FILE, ">$outputs_list_filename") || die "Can't create outputs_list_file $outputs_list_filename\n";
my $address_map_filename = $opt{module_name}.$address_map_filename_suffix ;

if (($opt{gen_test}) && ($opt{host_test})) {
    my $host_test_def_filename   = $opt{module_name}.$host_test_def_file_suffix ;
    my $host_test_WR_RD_FF_filename  = $opt{module_name}.$host_test_WR_RD_FF_file_suffix ;
    my $host_test_WRCNT_filename = $opt{module_name}.$host_test_WRCNT_file_suffix ;
    my $host_test_RDCNT_filename = $opt{module_name}.$host_test_RDCNT_file_suffix ;
    open(HOST_TEST_DEF_FILE, ">$host_test_def_filename") || die "Can't create reg test file $host_test_def_filename\n";
    open(HOST_TEST_WR_RD_FF_FILE, ">$host_test_WR_RD_FF_filename") || die "Can't create reg test file $host_test_WR_RD_FF_filename\n";
    open(HOST_TEST_WRCNT_FILE, ">$host_test_WRCNT_filename") || die "Can't create reg test file $host_test_WRCNT_filename\n";
    open(HOST_TEST_RDCNT_FILE, ">$host_test_RDCNT_filename") || die "Can't create reg test file $host_test_RDCNT_filename\n";
}

#calc the max value of HADDRESSES in order to calc the size of the reg addr range:
my $max_haddr = 0;
foreach my $haddr (keys %HADDRESSES) {
    if ($max_haddr < eval("0x$HADDRESSES{$haddr}")) {
        $max_haddr = eval("0x$HADDRESSES{$haddr }")
    }
}                               #foreach

&insert_header(REG_DEC_FILE);
&insert_header(IOS_DEC_FILE);
&insert_header(IOS_LIST_FILE);
$pulse_found = 0;

$max_reg_length = $max_reg_length + 2 ;
$max_field_length = $max_reg_length + $max_field_length + 3 ;

$reg_number  = 0;


#*********************************  -------------------------------------------- *********************************
#*********************************  HERE STARTS THE CREATION OF THE HEADER FILE     *********************************
#*********************************  -------------------------------------------- *********************************
# Search for the base address of the address_map and extract the address
open(my $fh, '>', 'keywords.txt');
# Here we should put the name of the base addess name that we want (recieve this parameter from the bash script)
print $fh "$opt{base_address_name}\n";
close $fh;
open my $keywords,    '<', 'keywords.txt' or die "Can't open keywords: $!";
open my $search_file, '<', "$opt{address_map_file}"   or die "Can't open search file: $!";
my $keyword_or = join '|', map {chomp;qr/\Q$_\E/} <$keywords>;
my $regex = qr|\b($keyword_or)\b|;
my $line = "";
my $num_of_base_address_instances=0;
while (<$search_file>)
{
    $line = $_;
    while (/$regex/g)
    {
        $BASE_ADDRESS = substr($_, 0, index($_, ' '));
        $BASE_ADDRESS_ARRAY[$num_of_base_address_instances] = $BASE_ADDRESS;
        $num_of_base_address_instances++; # increment the counter of number of base addresses instances
    }
}
unlink 'keywords.txt' or warn "Could not unlink $file: $!";


# Now "num_of_base_address_instances" is the number of loop we need to do,
# and "BASE_ADDRESS_ARRAY" holds the adresses of this blocks.


for (my $i=0; $i < $num_of_base_address_instances; $i++){

    #The suffix should be empty ("") in case there is only 1 onstance for this base address.
    #The suffix should be "_<number of the current instance>".
    #This should be applied to the file name, the base address name, and the ifndef.
    if ($num_of_base_address_instances != 1) { $suffix = "_$i"; }

    $reg_header_filename = join "", $opt{module_name}, "$suffix", ".h"; # concatinate these strings

    open(REG_HEADER_FILE, ">$opt{sw_headers_path}/$reg_header_filename") || die "Can't create reg_header_file $reg_header_filename\n";


    my $curr_time = localtime; # scalar context
    # Convert the module name to capital letters, and add it's instance in case exist more than 1:
    my $module_name_capital_letters = uc $opt{module_name};

    printf (REG_HEADER_FILE "/*\n");
    printf (REG_HEADER_FILE " * Filename \t: $opt{chip_name}_SOC_Registers.h\n");
    printf (REG_HEADER_FILE " *\n");
    printf (REG_HEADER_FILE " * Created on   : $curr_time\n");
    printf (REG_HEADER_FILE " *\n");
    printf (REG_HEADER_FILE " */\n");
    printf (REG_HEADER_FILE "#ifndef ${module_name_capital_letters}_REGISTERS_H_\n");
    printf (REG_HEADER_FILE "#define ${module_name_capital_letters}_REGISTERS_H_\n");
    printf (REG_HEADER_FILE "\n#define cyg_uint32 unsigned int\n\n");
    printf (REG_HEADER_FILE "//=============================================================================\n");
    printf (REG_HEADER_FILE "//  BLOCK $module_name_capital_letters\n");
    printf (REG_HEADER_FILE "//=============================================================================\n");
    printf (REG_HEADER_FILE "#define   ${module_name_capital_letters}_BASE_ADDR${suffix}  0x$BASE_ADDRESS_ARRAY[$i]\n\n\n");


    for (@REGS) {
        $register_first_time=1;
        $t_reg = $_ ;

        $first_field = 1;
        $writable_found = 0;

        #used for determing if reserved field is necessary
        $prev_msbits = 0;

        printf (REG_HEADER_FILE "//=============================================================================\n");
        printf (REG_HEADER_FILE "// $t_reg\n");

#        for (@$t_reg) {
#            $t_field = $_ ;
#
#            $bit_gap = $LSBITS{$t_field}-$prev_msbits;
#            if ( ($bit_gap != 1) && ($register_first_time == 0) ){
#                printf (REG_HEADER_FILE "\t\tcyg_uint32\treserve_%d_%d : %d;\n", $prev_msbits+1, $LSBITS{$t_field}-1, $bit_gap-1);
#            }
#
#            $prev_msbits = $MSBITS{$t_field};
#
#            if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")) { $writable_found = 1; }
#
#            if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "WO")||($TYPES{$t_field} eq "PULSE")||($TYPES{$t_field} eq "SINGLE_PULSE")||($TYPES{$t_field} eq "RW_PULSE")||($TYPES{$t_field} eq "RW_INTERNAL")||($TYPES{$t_field} eq "RO")) {
#                if ( $register_first_time ){
#                    printf (REG_HEADER_FILE "typedef union {\n");
#                    printf (REG_HEADER_FILE "\tcyg_uint32 value;\n");
#                    printf (REG_HEADER_FILE "\tstruct {\n");
#                    $register_first_time=0;
#                }
#                $bit_gap = $MSBITS{$t_field}-$LSBITS{$t_field};
#                printf (REG_HEADER_FILE "\t\tcyg_uint32\t%s : %d;\n", $t_field, $bit_gap+1);
#            }
#        }
#        # Check if the struct was created (if so - close the brackets)
#        if ( $register_first_time != 1 ){
#            if ( ( $prev_msbits+2 != $register_size ) && ( $register_size-$prev_msbits-1 != 0 ) ){
#                printf (REG_HEADER_FILE "\t\tcyg_uint32\treserve_%d_%d : %d;\n", $prev_msbits+1, $register_size-1, $register_size-$prev_msbits-1);
#            }
#            printf (REG_HEADER_FILE "\t}bits;\n");
#            printf (REG_HEADER_FILE "}$opt{module_name}_${t_reg}_union;\n");
#        }
        my $t_reg_capital_letters = uc ${t_reg};
        printf (REG_HEADER_FILE "#define ${module_name_capital_letters}_${t_reg_capital_letters}_ADDR (${module_name_capital_letters}_BASE_ADDR$suffix + 0x$HADDRESSES{$t_reg})\n");
        my $t_reg_name_capital_letters = uc $MAINNAME{$t_reg};
        printf (REG_HEADER_FILE "#define ${module_name_capital_letters}_${t_reg_name_capital_letters}_ADDR (${module_name_capital_letters}_BASE_ADDR$suffix + 0x$HADDRESSES{$t_reg})\n");
        printf (REG_HEADER_FILE "//=============================================================================\n\n");
        $reg_number += 1;
    }
    printf (REG_HEADER_FILE "\n\n#endif /* ${module_name_capital_letters}_REGISTERS_H_ */\n");
    close (REG_HEADER_FILE);
}


close (PAR_DEF_FILE);
close (REG_DEC_FILE);
close (IOS_DEC_FILE);
close (IOS_LIST_FILE);

sub mask_to_size_lsb_msb {
    my $hmask;
    my $mask;
    my $tmp_mask;
    my $bitsize;
    my $lsbit;
    my $msbit;
    my $bit31 ;
    my $f = 0 ;

    $hmask = shift ;
    $mask = hex($hmask);
    $bit31 = $mask & 2147483648 ;
    $bit31 = $bit31 >> 31 ;
    $lsbit = 0 ;
    $bitsize = 1;

    #Yaniv Costica: IMPORTANT!
    # Note that if this script is running on a linux system with Big Endian, the line below should be uncommented!
    #                                 if this script is running on a linux system with Small Endian, the line below should stay as comment
    # to check if this system is big endian or small endian, run the following command in terminal:
    # echo -n I | od -to2 | head -n1 | cut -f2 -d" " | cut -c6
    # if result is 0 --> it's a Big Endian system.
    # if result is 1 --> it's a Small Endian system.
    # look for the LSB by looking for the first bit == 1
    $mask = $mask << 1;
    do { $mask = $mask >> 1;
         $f = 1 ;
         $tmp_mask = ($mask >> 1) << 1 ;
         $lsbit += 1 ;
    } while ( $tmp_mask == $mask ) ;
    $lsbit -= 1 ;
    $msbit = $lsbit ;
    # look for the MSB
    do { $mask = $mask >> 1;
         $tmp_mask = ($mask >> 1) << 1 ;
         $msbit += 1 ;
    } while ( $tmp_mask != $mask ) ;
    $bitzise = $msbit - $lsbit ;
    $msbit -= 1;
    return ($bitzise,$msbit,$lsbit)
}

sub shlof_bitim {
    my $hvalue = shift ;
    my $lsbits   = shift ;
    my $width = shift ;
    my $mask = 2**$width - 1;
    $hvalue = hex($hvalue);
    $hvalue = $hvalue >> $lsbits ;
    $hvalue = $hvalue & $mask ;
    $hvalue = sprintf "%lx",$hvalue ;
    return ($hvalue);
}

##************************************************************
##  Sets tha max width of the registers
##************************************************************
sub get_max_reg_width {
    $max_reg_width = 0;
    for (@REGS) {
        $t_reg = $_;
        for (@$t_reg) {
            $t_field = $_;
            if (($TYPES{$t_field} ne "RO")||($TYPES{$t_field} eq "RO_PULSE")) {
                if ($SIZES{$t_field} > $max_reg_width) {
                    $max_reg_width  = $SIZES{$t_field};
                }
            }
        }
    }
    return ($max_reg_width - 1);
}


##************************************************************
##  Inserts header file
##************************************************************
sub insert_header {
    $fid = $_;

    #    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    #
    #    open(fid1,  $header_file) || die "Can't open $header_file \n";
    #    for (<fid1>) {
    #        printf(fid "$_") ;
    #    }
    #    $mon  += 1;
    #    $year += 1900;
    #    if ($hour < 10) { $hour = "0" . $hour; }
    #    if ($min  < 10) { $min  = "0" . $min;  }
    #    if ($sec  < 10) { $sec  = "0" . $sec;  }
    #    printf (fid "\n\/*************************************************************\n");
    #    printf (fid " * Automatically created by gen_regfile_hdl script\n");
    #    printf (fid " * At: $mday-$mon-$year $hour:$min:$sec\n");
    #    printf (fid " *************************************************************\/\n\n");
}
