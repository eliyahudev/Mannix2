#!/usr/local/bin/perl

sub usage {
my $help = <<EOM;

gen_reg_file_constraints.pl

Usage:

     $0 [various parameters...]  <EXCEL_EXPORT_FILE>

       where  EXCEL_EXPORT_FILE    is Input Text file name generated by Excell. (Mandatory)

     The various parameters needed are:

        -h                      Show help info.
        -module=<MODULE>        MODULE  is the module name as it appears in the first coloum.
        -output=<OUTPUT>        OUTPUT  is the prefix for the output file. defalut is the module name.
                                The output files are MODULE.sdc and MODULE.tcl
        -asic_path=<ASIC_PATH>  ASIC_PATH the hierarcy path to the registers module in the asic design.
        -fpga_path=<FPGA_PATH>  FPGA_PATH the hierarcy path to the registers module in the fpga design.

Description:
     This script will generate constraints for FPGA and ASIC according to the Excel Export file,
     which will false path all programming model registers that have RW capability.
     =====================================================================
     BE ADVISED: all registers will be set as false path.
     excluding specific register should be done in a seperate script.
     =====================================================================

example:
     $0  -module=phase_loop -output=phase_loop_regfile_constraint -asic_path="phy/rx_phase_loop_ss/rx_phase_loop_rf" -fpga_path="phy.rx_phase_loop_ss.rx_phase_loop_rf" ./ExcelExport.txt
EOM

print $help;
}

sub get_options {
  my $arg ;
  $opt{extra_space} = 0;
  while (@_) {
    $arg = shift ;
    $arg =~ /^-h$/ && do { &usage; exit 1;};
    $arg =~ /-module=/ && do {$arg =~ s/-module=(\w+)/$1/s;         $opt{module_name}=$arg; next};
    $arg =~ /-output=/ && do {$arg =~ s/-output=(\w+)/$1/s;         $opt{output}=$arg; next};
    $arg =~ /-asic_path=/ && do {$arg =~ s/-asic_path=(\w+)/$1/s;   $opt{asic_path}=$arg; next};
    $arg =~ /-fpga_path=/ && do {$arg =~ s/-fpga_path=(\w+)/$1/s;   $opt{fpga_path}=$arg; next};
    $arg =~ /-intc_name=/ && do {$arg =~ s/-intc_name=(\w+)/$1/s;   $opt{intc_name}=$arg; next};
    $arg =~ /-intc_name2=/ && do {$arg =~ s/-intc_name2=(\w+)/$1/s; $opt{intc_name2}=$arg; next};
    $arg =~ /-intc_name3=/ && do {$arg =~ s/-intc_name3=(\w+)/$1/s; $opt{intc_name3}=$arg; next};
    $arg =~ /-intc_name4=/ && do {$arg =~ s/-intc_name4=(\w+)/$1/s; $opt{intc_name4}=$arg; next};
    (($arg !~ /-/ )&&($arg =~ /\w+/)) && do { $opt{ExcelExportFile}=$arg ; next};

  }
  die ("No file_name specified\nType $0 -h to get help\n\n") unless ($opt{ExcelExportFile});
}

########################
#                      #
#  Program Starts Here #
#                      #
########################
$|=1; # immediate output

use vars qw( %opt );
$version = "1.00a";


$opt{intc_name}= "";
$opt{intc_name2}= "";
$opt{intc_name3}= "";
$opt{intc_name4}= "";

my @TMP ;
my $t_module ;
my $t_reg ;
my $t_field ;
my $t_mask ;
my $t_type ;
my $t_falsepath ;
my %HADDRESSES ;# each key is a reg name, each value is the address of that reg
my %IADDRESSES ;# same as HADDRESSES, only masked
my @REGS ;# list of all regs
my %TYPES ;
my %FALSEP ;
my %SIZES ;
my %LSBITS ;
my %MSBITS ;
my %RESET_VALS ;
my %MASKS ;
my $t_bitzise ;
my $t_msbit ;
my $t_lsbit ;
my $fpga_output ;
my $asic_output ;
my @INTC;

&get_options (@ARGV);  # fills global hash %opt
if ($opt{output} ne "")
  { $fpga_output = $opt{output}.".sdc";
    $asic_output = $opt{output}.".tcl";
  }
else
  { $fpga_output = $opt{module_name}.".sdc";
    $asic_output = $opt{module_name}.".tcl";
  }

open(EXCEL_FILE,$opt{ExcelExportFile})|| die "Could not open Excel export file $opt{ExcelExportFile}\n";
# open(FPGA_CONSTRAINTS_FILE,">$fpga_output") || die "Could not open FPGA constraints file for output.\n";
open(ASIC_CONSTRAINTS_FILE,">$asic_output") || die "Could not open ASIC constraints file for output.\n";


if ($opt{intc_name} ne "") {
  push @INTC, $opt{intc_name};
}
if ($opt{intc_name2} ne "") {
  push @INTC, $opt{intc_name2};
}
if ($opt{intc_name3} ne "") {
  push @INTC, $opt{intc_name3};
}
if ($opt{intc_name4} ne "") {
  push @INTC, $opt{intc_name4};
}



my @EE_LINES ;
@EE_LINES = <EXCEL_FILE> ;

for (@EE_LINES) {
    chop;
    @TMP = split " ",$_ ;
    $t_module = @TMP[0] ;
    #    if ($opt{module_name} eq "XXX") {$opt{module_name} = $t_module;}
    #    if ($t_module eq $opt{module_name})
    # do only if module name is as requested
    #      {

    $t_reg = @TMP[0] ;
    $t_field = lc(@TMP[2]) ;
    $t_mask = @TMP[4] ;
    $t_type = @TMP[5] ;
    $t_falsepath = @TMP[7] ;
    # ronen False Path is always paramter number 7
    #    if ( $#TMP == 7) {$t_falsepath =  @TMP[7];} # all fields are defined
    #    else {
    #      if  ( $#TMP == 6) {$t_falsepath =  @TMP[6];} # no shadow reg
    #      else {$t_falsepath = "No";}
    #      }
    my $intc_input = 0;
    my $intc_sig = 0;
    my $intc_name = "";
    foreach $t_intc (@INTC) {
        if ($t_field =~ ("_$t_intc\$")) {
            $intc_input = 1; $intc_name = $t_intc;
        }
        if ($t_field =~ ("_$t_intc"."_")) {
            $intc_sig = 1;   $intc_name = $t_intc;
        }
        my $t_intc_mask = $t_intc."_mask";
        if ($t_field =~ /$t_intc_mask/ ) {$INTC_ON{$t_intc} = 1;}
    }
    $INTC_INPUT{$t_field} = $intc_input;
    $INTC_NAME{$t_field}   = $intc_name;
    print("");


    # check if the register was defined before
    if (exists $HADDRESSES{$t_reg}) {
        # if reg was defined, then must add this field to the reg field list
        @TMP = @$t_reg ;
        push @TMP,$t_field ;
        @$t_reg = @TMP ;
    } else {
        # if reg was not defined before then define it
        $HADDRESSES{$t_reg} = $t_haddress ;# add reg address to HADDRESSES hash
        $IADDRESSES{$t_reg} = $t_iaddress ;
        push @REGS,$t_reg ; # add reg to REGS list
        @$t_reg = ($t_field);# define the first field
    }

    # check if field was defined. I assume a field can only have one defenition
    if (not exists $TYPES{$t_field}) {
        # define this field
        $MASKS{$t_field}  = $t_mask ;
        ($t_bitzise,$t_msbit,$t_lsbit) = mask_to_size_lsb_msb($t_mask);# get size,LSB,MSB
        $SIZES{$t_field}  = $t_bitzise ;
        $MSBITS{$t_field} = $t_msbit ;
        $LSBITS{$t_field} = $t_lsbit ;
        $TYPES{$t_field}  = $t_type ;
        $FALSEP{$t_field} = $t_falsepath ;
    }

    ##  print ("Working On $TYPES{$t_field} $MASKS{$t_field} $SIZES{$t_field} $TYPES{$t_field} $FALSEP{$t_field} \n");

}

for (@INTC) {
    $t_intc = $_;
    if ($INTC_ON{$t_intc} eq 1) {
        for (@REGS) {
            $t_reg = $_ ;
            for (@$t_reg) {
                $t_field = $_ ;
                if (($INTC_INPUT{$t_field}) && ($INTC_NAME{$t_field} eq $t_intc)) {
                    $INTERRUPT{$t_field}= "1";
                }
            }
        }
    }
}


#  }

# Construct a collection of all registers under required scope:
printf ASIC_CONSTRAINTS_FILE "# Construct a collection of all registers under required scope for reuse (run-time efficiency):\n";
printf ASIC_CONSTRAINTS_FILE "set reg_data_pins_collection [filter_collection [get_pins -hier *reg*\/?] {hierarchical_name =~ .*%s.*/[dDqQ]} -regexp]\n\n", $opt{asic_path};

for (@REGS) {
    $t_reg = $_ ;
    for (@$t_reg) {
        $t_field = $_ ;
        # gpr gpo register should not have a false path
        if (($TYPES{$t_field} eq "RW") && ($FALSEP{$t_field} eq "Yes") && (($t_field =~ "gpr") || ($t_field =~  "gpo"))) {
            die ("Note GPR and GPO registers should not have a False path, The script doesn't support it \n\n")
        }

        # MODIFIED by Slava Yuzhaninov (yuzhans@biu.ac.il) on 13-11-2018:
        elsif ((($TYPES{$t_field} eq "RW") || ($TYPES{$t_field} eq "WO")) && ($FALSEP{$t_field} eq "Yes")) {
            printf ASIC_CONSTRAINTS_FILE "set_false_path -through [filter_collection \$reg_data_pins_collection {hierarchical_name =~ *%s*}]\n", $t_field;
            # printf ASIC_CONSTRAINTS_FILE "set_false_path -through [get_pins -hier *reg*\/q -nocase -filter {hierarchical_name =~ *%s*%s*}]\n", $opt{asic_path},  $t_field;
            # printf ASIC_CONSTRAINTS_FILE "set_false_path -through [get_pins -hier *\/q -nocase -filter {hierarchical_name =~ *%s*}", $t_field;
            # if ($SIZES{$t_field} > 1) { printf ASIC_CONSTRAINTS_FILE "*\/Q]\n"; }
            # elsif ($INTERRUPT{$t_field} eq "1"){ printf ASIC_CONSTRAINTS_FILE "*\/Q]\n"; }
            # else {printf ASIC_CONSTRAINTS_FILE "*\/Q]\n";}

            # COMMENTED out by Slava Yuzhaninov (yuzhans@biu.ac.il) on 25-01-2019:
            # printf FPGA_CONSTRAINTS_FILE "set_false_path  -from {%s|%s",$opt{fpga_path},$t_field;
            # if ($SIZES{$t_field} > 1) { printf FPGA_CONSTRAINTS_FILE "[*]}\n";}
            # elsif (exists $INTERRUPT{$t_field}){ printf FPGA_CONSTRAINTS_FILE"[*]}\n";}
            # else { printf FPGA_CONSTRAINTS_FILE "}\n";}
        }
    }
}

close(EXCEL_FILE);
# close(FPGA_CONSTRAINTS_FILE);
close(ASIC_CONSTRAINTS_FILE);
exit ;

sub mask_to_size_lsb_msb {
  my $hmask;
  my $mask;
  my $tmp_mask;
  my $bitsize;
  my $lsbit;
  my $msbit;
  my $bit31 ;
  my $f = 0 ;

  $hmask = shift ;
  $mask = hex($hmask);
  $bit31 = $mask & 2147483648 ;
  $bit31 = $bit31 >> 31 ;
  $lsbit = 0 ;
  $bitsize = 1;

# Note that if this script is running on a linux system with Big Endian, the line below should be uncommented!
#                                 if this script is running on a linux system with Small Endian, the line below should stay as comment
# to check if this system is big endian or small endian, run the following command in terminal:
# echo -n I | od -to2 | head -n1 | cut -f2 -d" " | cut -c6
# if result is 0 --> it's a Big Endian system.
# if result is 1 --> it's a Small Endian system.

  # look for the LSB by looking for the first bit == 1
  $mask = $mask << 1;
  do { $mask = $mask >> 1;
         # ben deleted for case 32 bits data width
         #      if ($f==0 && $bit31 == 1) {$mask += 2147483648;}
         #   if ($f==0 && $bit31 == 1) {$mask += 2147483648;}
       $f = 1 ;
       $tmp_mask = ($mask >> 1) << 1 ;
       $lsbit += 1 ;
     } while ( $tmp_mask == $mask ) ;
  $lsbit -= 1 ;
  $msbit = $lsbit ;
  # look for the MSB
  do { $mask = $mask >> 1;
       $tmp_mask = ($mask >> 1) << 1 ;
       $msbit += 1 ;
      } while ( $tmp_mask != $mask ) ;
  $bitzise = $msbit - $lsbit ;
  $msbit -= 1;
  return ($bitzise,$msbit,$lsbit)
}
