#!/usr/local/bin/perl

use POSIX qw(ceil floor);
use Data::Dumper qw(Dumper);

sub usage {
  my $help = <<EOM;

gen_regfile_hdl Version $version

Usage:

     $0  [various parameters...]  <EXCEL_EXPORT_FILE>

       where  EXCEL_EXPORT_FILE    is Input Text file name generated by Excell. (Mandatory)

     The various parameters needed are:

        -h                   Show help info.
        -module=<MODULE>     MODULE  is the module name as it appears in the first coloum.
                                     the default is the first one that listed in EXCEL_EXPORT_FILE.
        -type=<TYPE>         TYPE    is cs_r_wn  for architecture with CS + R_WN     (default)
                                     or rd_wr_en for architecture with RD_EN + WR_EN
        -clock=<CLOCK>       CLOCK   is the name of the clock signal. default is clk.
        -reset=<RESET>       RESET   is the name fo the active low reset signal. default is reset_n.
        -cs=<CS>             CS      is the name of the Chip select signal. default is hcs.
        -r_wn=<R_WN>         R_WN    is the name of the Read/Write_not signal. default is h_r_wn.
        -rd_en=<RD_EN>       RD_EN   is the name of the read enable signal. default is hrd.
        -wr_en=<WR_EN>       WR_EN   is the name of the write enable signal. default is hwr.
        -address=<ADDRESS>   ADDRESS is the name of the address bus. default is h_addr
        -aw=<AW>             AW      is the width of the address bus. default is 16  (integer).
        -wr_pulse_out=<0|1>  0|1     is the condition for outputting wr_pulse. default is 0  (integer).
        -shift_addr=<SHIFT>  SHIFT   is how much shift right should be done on ADDRESS. default is 2 (integer).
        -data=<DATA>         DATA    is the name of the data bus. default is h_data.
        -dat_out=<DOUT>      DOUT    is the name of the output data bus. default is dat_out.
        -ack_out=<ACK>       ACK     is the name of the acknowledge output signal. default is ack_out.
        -dw=<DW>             DW      is the width of the data bus. default is 32  (integer).
        -mips_test           generate registers test in MIPS assembler
        -host_test           generate registers test in host commands
        -vera=<NAME>         DW      is the name of the vera block.
        -mem=<MEM_FILE>      MEM_FILE    is the name of the memory file for vera.
        -dut=<MODULE_FILE>   MODULE_FILE is the path and file name of the dut top module
            -intc_name=<INTC_NAME> INTC_NAME is the interupt controler name prefix. the scripts will look for *<INTC_NAME>_MASK register with GUI type
            -intc_name2=<INTC_NAME> INTC_NAME is the interupt controler name prefix. the scripts will look for *<INTC_NAME>_MASK register with GUI type
        -rd_wr_intc_name               which intc is for illegal read and writes from host
        -cdc                           controls if there is more than one clock domain
        -sw_mapping_addr_path        is a pointer to the folder of S/W register files address mapping

Description:
     This script will generate the Write/Read Verilog portion of the
     programming model register file.

EOM

  print $help;
}


sub get_options {
    my $arg ;
    $opt{extra_space} = 0;
    while (@_) {
        $arg = shift ;
        $arg =~ /^-h$/ && do { &usage; exit 1;};
        $arg =~ /-type=/ && do {$arg =~ s/-type=(\w+)/$1/s;             $opt{type}=$arg; next};
        $arg =~ /-module=/ && do {$arg =~ s/-module=(\w+)/$1/s;         $opt{module_name}=$arg; next};
        $arg =~ /-clock=/ && do {$arg =~ s/-clock=(\w+)/$1/s;           $opt{clock}=$arg; next};
        $arg =~ /-reset=/ && do {$arg =~ s/-reset=(\w+)/$1/s;           $opt{reset}=$arg; next};
        $arg =~ /-cs=/ && do {$arg =~ s/-cs=(\w+)/$1/s;                 $opt{cs}=$arg; next};
        $arg =~ /-r_wn=/ && do {$arg =~ s/-r_wn=(\w+)/$1/s;             $opt{r_wn}=$arg; next};
        $arg =~ /-rd_en=/ && do {$arg =~ s/-rd_en=(\w+)/$1/s;           $opt{rd_en}=$arg; next};
        $arg =~ /-wr_en=/ && do {$arg =~ s/-wr_en=(\w+)/$1/s;           $opt{wr_en}=$arg; next};
        $arg =~ /-address=/ && do {$arg =~ s/-address=(\w+)/$1/s;       $opt{address}=$arg; next};
        $arg =~ /-address_map_file=/ && do {$arg =~ s/-address_map_file=([\w\/]+)/$1/s;       $opt{address_map_file}=$arg; next};
        $arg =~ /-phy_number=/ && do {$arg =~ s/-phy_number=(\d+)/$1/s; $opt{phy_number}=$arg; next};
        $arg =~ /-aw=/ && do {$arg =~ s/-aw=(\d+)/$1/s;                 $opt{aw}=$arg; next};
        $arg =~ /-wr_pulse_out=/ && do {$arg =~ s/-wr_pulse_out=(\d+)/$1/s; $opt{wr_pulse_out}=$arg; next};
        $arg =~ /-shift_addr=/ && do {$arg =~ s/-shift_addr=(\d+)/$1/s; $opt{shift_a}=$arg; next};
        $arg =~ /-data=/ && do {$arg =~ s/-data=(\w+)/$1/s;             $opt{data}=$arg; next};
        $arg =~ /-dat_out=/ && do {$arg =~ s/-dat_out=(\w+)/$1/s;       $opt{dat_out}=$arg; next};
        $arg =~ /-ack_out=/ && do {$arg =~ s/-ack_out=(\w+)/$1/s;       $opt{ack_out}=$arg; next};
        $arg =~ /-dw=/ && do {$arg =~ s/-dw=(\d+)/$1/s;                 $opt{dw}=$arg; next};
        $arg =~ /-mips_test/ && do {                                    $opt{gen_test}= 1; $opt{mips_test}= 1; next};
        $arg =~ /-host_test/ && do {                                    $opt{gen_test}= 1; $opt{host_test}= 1; next};
        $arg =~ /-vera=/ && do {$arg =~ s/-vera=(\w+)/$1/s;             $opt{vera_name}=$arg; next};
        $arg =~ /-mem=/ && do {$arg =~ s/-mem=(\w+)/$1/s;               $opt{mem_file}=$arg; next};
        $arg =~ /-dut=/ && do {$arg =~ s/-dut=(\w+)/$1/s;               $opt{dut}=$arg; next};
        $arg =~ /-intc_name=/ && do {$arg =~ s/-intc_name=(\w+)/$1/s;   $opt{intc_name}=$arg; next};
        $arg =~ /-intc_name2=/ && do {$arg =~ s/-intc_name2=(\w+)/$1/s; $opt{intc_name2}=$arg; next};
        $arg =~ /-intc_name3=/ && do {$arg =~ s/-intc_name3=(\w+)/$1/s; $opt{intc_name3}=$arg; next};
        $arg =~ /-intc_name4=/ && do {$arg =~ s/-intc_name4=(\w+)/$1/s; $opt{intc_name4}=$arg; next};
        $arg =~ /-intc_clk_name=/ && do {$arg =~ s/-intc_clk_name=(\w+)/$1/s; $opt{intc_clk_name}=$arg; next};
        $arg =~ /-multy_int=/ && do {$arg =~ s/-multy_int=(\w+)/$1/s; $opt{multy_int}=$arg; next};
        $arg =~ /-rd_wr_intc_name=/ && do {$arg =~ s/-rd_wr_intc_name=(\w+)/$1/s;   $opt{rd_wr_intc_name}=$arg; next};
        $arg =~ /-sw_mapping_addr_path=/ && do {$arg =~ s/-sw_mapping_addr_path=([\w\/]+)/$1/s;       $opt{sw_mapping_addr_path}=$arg; next};
        $arg =~ /-cdc=/ && do {$arg =~ s/-cdc=(\w+)/$1/s;             $opt{cdc}=$arg; next};
        (($arg !~ /-/ )&&($arg =~ /\w+/)) && do { $opt{ExcelExportFile}=$arg ; next};
    } die ("No file_name specified\nType $0 -h to get help\n\n") unless ($opt{ExcelExportFile});
}



########################
#                      #
#  Program Starts Here #
#                      #
########################
$|=1;                           # immediate output

use vars qw( %opt );
use POSIX ;

$version = "1.00a";

if ( $#ARGV < 0) {               # In perl language the first parameter index is 0
    printf("No Excel Export file was given !!!\n");
    printf("Invoke with:  gen_regfile_hdl -h for help.\n");
    exit 1;
}                               # Not enough parameters ends here

$opt{type}= "cs_r_wn";
$opt{module_name}= "XXX";
$opt{cdc}=0;
$opt{clock}= "clk";
$opt{gclock}= "gclk";
$opt{reset}= "reset_n";
$opt{hreset}= "hw_reset_n";
$opt{cs}= "h_cs";
$opt{r_wn}= "h_r_wn";
$opt{rd_en}= "hrd";
$opt{wr_en}= "hwr";
$opt{address}= "h_addr";
$opt{aw}= 8;
$opt{phy_number}= 0;
$opt{wr_pulse_out}= 0;
$opt{pulse_addr_ios}= 0;
$opt{pulse_addr_inputs}= "";
$opt{pulse_addr_ports}= "";
$opt{reset_ctrl}=0;
$opt{add_gclk_ins}= 1;
$opt{shift_a}= 2;
$opt{data}= "h_data";
$opt{dw}= 32;
$opt{vera_name}= "";
$opt{dat_out}= "dat_out";
$opt{ack_out}= "ack_out";
$opt{ExcelExportFile}="UNDEFINED";
$opt{gen_test}= 0;
$opt{mips_test}= 0;
$opt{host_test}= 0;
$opt{vera_name}= "";
$opt{dut}= "";
$opt{mem_file}= "";
$opt{intc_name}= "";
$opt{intc_name2}= "";
$opt{intc_name3}= "";
$opt{intc_name4}= "";
$opt{intc_clk_name}= "rf_clk";
$opt{rd_wr_intc_name}= "irq_sig"; ###this was done for legacy reasons!!!!
$opt{multy_int}= "";
$opt{sw_mapping_addr_path}="";


&get_options (@ARGV);           # fills global hash %opt

print "MODULE_NAME = $opt{module_name}\n";
print "INTC_CLK_NAME = $opt{intc_clk_name}\n";
my $mask_width = ceil($opt{dw}/4) ;
my $bitsize;
my $lsbit;
my $msbit;
#prev_msbits is used to decide whether resreved fields are needed in vr_ad definitions.
my $prev_msbits;
my @REGS ;                      # list of all regs
my %HADDRESSES ;                # each key is a reg name, each value is the address of that reg
my %IADDRESSES ;                # same as HADDRESSES, only masked
my %MAINNAME ;                  # Main name of GUI registers
my %AVOID_HOST ;
my %SIZES ;
my %LSBITS ;
my %MSBITS ;
my %RESET_VALS ;
my %DV_RESET_VALS ;
my %TYPES ;
my %MASKS_FIELDS ;
my %MASKS_REGS ;
my %INTC_INPUT;
my %INTC_NAME;
my %INTC_ON;
my %INTC_SIG;
my %INTC_BITSIZE;
my %INTC_MSBIT;
my %INTC_LSBIT;
my %SRST_OUTPUT;
my %SRST_SIG;
my %SRST_BITSIZE;
my %SRST_MSBIT;
my %SRST_LSBIT;

#my $cs_d ;
my $intc_tmp ;
my $tmp ;
my $tmp2 ;
my @TMP ;
my $t_module ;
my $t_reg ;
my $reg_number ;
my $t_haddress ;
my $t_iaddress ;
my $t_field ;
my $t_mask ;
my $t_type ;
my $t_reset ;
my $t_bitzise ;
my $t_msbit ;
my $t_lsbit ;
my $reg_dec_filename = "declarations.v" ;
my $rw_logic_filename = "read_write_logic.v";
my $clock_gate_filename = "cg_logic.v";
my $address_map_filename_suffix = "_address_map.txt";
my $mips_test_def_file_suffix = "_mips_test_def.s";
my $mips_test_WR_RD_FF_file_suffix = "_mips_test_WR_RD_FF.s";
my $specman_test_WR_RD_FF_file_suffix = "_mips_test_WR_RD_FF.e";
my $specman_test_CNT_FF_file_suffix = "_mips_test_CNT_FF.e";
my $specman_test_CHK_DEFAULTS_RD_FF_file_suffix = "_mips_test_CHK_DEFAULTS_FF.e";
my $mips_test_WRCNT_file_suffix = "_mips_test_WRCNT.s";
my $mips_test_RDCNT_file_suffix = "_mips_test_RDCNT.s";

my $host_test_def_file_suffix = "_host_test_def.ini";
my $host_test_WR_RD_FF_file_suffix = "_host_test_WR_RD_FF.ini";
my $host_test_WRCNT_file_suffix = "_host_test_WRCNT.ini";
my $host_test_RDCNT_file_suffix = "_host_test_RDCNT.ini";

my $read_reset_value ;
my $expected_read_val ;
my $outputs_dec_filename = "outputs_declare.v" ;
my $outputs_list_filename = "outputs_list.v" ;
my $parameters_def_filename = "parameters_def.v" ;
my $writable_found ;
my $pulse_found ;
my $first_field ;
my $module_name_length ;
my $max_reg_length = 0 ;
my $max_field_length = 0;
my $reg_cnt_test_count ;
my $t_length ;
my $t_mask_length ;
my $max_reg_width;

my %PARAM = ();
my %MEMO = ();
my @mem_name;
my @mem_width;
my @limit;
my $k=0;
my $mem_arr_name="mem_core_array";

my @INTC;
my $intc_bitzise;
my $intc_msbit;
my $intc_lsbit;
my $intc_type;
my $t_clock_domain = "rf_clk";
my $intc_reset = "hw_reset_n";

my @SRST;
my $srst_bitzise;
my $srst_msbit;
my $srst_lsbit;
my $srst_type;
my $srst_on = 0;
my $t_mask_new = 0;
my $t_mask_hex = 0 ;
my $last_gui = 0;

my $aw_trunc = $opt{aw}-2;

${gclk_en_ored} = "";
${pulse_addr} = "";
${pre_pulse_addr} = "";

if ($opt{intc_clk_name} eq "cbus_rf_clk"){
    $opt{intc_clk_name} = "rf_clk";
}


if ($opt{intc_name} ne "") {
    push @INTC, $opt{intc_name};
}
if ($opt{intc_name2} ne "") {
    push @INTC, $opt{intc_name2};
}
if ($opt{intc_name3} ne "") {
    push @INTC, $opt{intc_name3};
}
if ($opt{intc_name4} ne "") {
    push @INTC, $opt{intc_name4};
}

push @SRST, "sreset_n";         # Remark this line to disable sreset logic

# retrieve block base address from address_map_file
open(ADDRESS_MAP_FILE,$opt{address_map_file})|| die "Could not open address map file $opt{address_map_file}\n";
my @AM_LINES ;
@AM_LINES = <ADDRESS_MAP_FILE> ;




$synch_regs = 0;

open(EXCEL_FILE,$opt{ExcelExportFile})|| die "Could not open Excel export file $opt{ExcelExportFile}\n";
my @EE_LINES ;
@EE_LINES = <EXCEL_FILE> ;
for (@EE_LINES) {
    chop;
    @TMP = split " ",$_ ;
    $t_module = @TMP[0] ;

    # do only if module name is as requested
    $t_reg = @TMP[0] ;
    $t_length = length($t_reg);
    if ($t_length > $max_reg_length) {
        $max_reg_length = $t_length ;
    }
    $t_haddress = @TMP[1] ;
    ($t_iaddress) = shlof_bitim($t_haddress,$opt{shift_a},16) ; #$opt{aw}) ; udi
    $t_field = lc(@TMP[2]) ;
    $t_length = length($t_field);
    if ($t_length > $max_field_length) {
        $max_field_length = $t_length ;
    }
    $t_mask = @TMP[4] ;
    $t_type = @TMP[5] ;
    $t_reset = @TMP[6] ;
    $t_False_path = @TMP[7];

    $t_signed = @TMP[8];
    $async_reset = @TMP[10];
    if($opt{cdc}) {
        $t_clock_domain = @TMP[11];
    }


    my $intc_input = 0;
    my $intc_sig = 0;
    my $intc_name = "";
    foreach $t_intc (@INTC) {
        if ($t_field =~ ("_$t_intc\$")) {
            $intc_input = 1; $intc_name = $t_intc;
        }
        if ($t_field =~ ("_$t_intc"."_")) {
            $intc_sig = 1;   $intc_name = $t_intc;
        }
    }
    my $srst_output = 0;
    my $srst_sig = 0;
    foreach $t_srst (@SRST) {
        if (($t_field =~ ("_$t_srst\$")) && !($t_field =~ ("_warm_sreset")))     {
            $srst_output = 1; ##print "srst_output |$t_field|\n";
        }
        if (($t_field =~ ("_$t_srst"."_")) || ($t_field =~ ("_warm_sreset"))) {
            $srst_sig = 1; ## print "srst_sig |$t_field|\n";
        }
    }

    if ($t_type eq "GUI") {
        foreach $t_intc (@INTC) {
            my $t_intc_mask = $t_intc."_mask";
            if ($t_field =~ /$t_intc_mask/ ) {
                print (">> Note: Creating Intteruppt Controller |".$opt{module_name}."_$t_intc|\n");
                ($intc_bitzise,$intc_msbit,$intc_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB
                $INTC_ON{$t_intc} = 1;
                $INTC_BITSIZE{$t_intc} = $intc_bitzise;
                $INTC_MSBIT{$t_intc} = $intc_msbit;
                $INTC_LSBIT{$t_intc} = $intc_lsbit;
            }
        }
        foreach $t_srst (@SRST) {
            my $t_srst_gui = $opt{module_name}."_".$t_srst;
            if ($t_field =~ /$t_srst_gui/ ) {
                print (">> Note: Creating SRESET Controller |$t_srst_gui|\n");
                ($srst_bitzise,$srst_msbit,$srst_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB
                $SRST_BITSIZE{$t_srst} = $srst_bitzise;
                $SRST_MSBIT{$t_srst} = $srst_msbit;
                $SRST_LSBIT{$t_srst} = $srst_lsbit;
                $srst_on = 1;
                $opt{reset_ctrl} = 1;

            }
        }
        $last_t_field = $t_field;
        $last_gui = 1;

    } else {
        # check if the register was defined before
        if (exists $HADDRESSES{$t_reg}) {
            # if reg was defined, then must add this field to the reg field list
            @TMP = @$t_reg ;
            push @TMP,$t_field ;
            @$t_reg = @TMP ;
        } else {
            # if reg was not defined before then define it
            $HADDRESSES{$t_reg} = $t_haddress ; # add reg address to HADDRESSES hash
            $IADDRESSES{$t_reg} = $t_iaddress ;
            if ($last_gui){
                $MAINNAME{$t_reg} = $last_t_field ;
            } else {
                $MAINNAME{$t_reg} = $t_field ;
            }
            $last_gui = 0;
            push @REGS,$t_reg ;       # add reg to REGS list
            @$t_reg = ($t_field);     # define the first field
        }
        {
            $AVOID_HOST{$t_reg} = 0;
        }

        # check if field was defined. I assume a field can only have one defenition
        if (not exists $TYPES{$t_field}) {
            # define this field
            $t_mask_length = length $t_mask;
            if ($t_mask_length  > $mask_width) {
                print ("WARNING: Field $t_field has mask wider than data bus width.\n");
            }
            $MASKS_FIELDS{$t_field}  = $t_mask ;
            if (($t_type eq "RW")|($t_type eq "RW_PULSE")) {
                $MASKS_REGS{$t_reg}  = sprintf "%.8lx",hex(lc(0x.$MASKS_REGS{$t_reg})) | hex(lc(0x.$t_mask)) ;
            }
            ($t_bitzise,$t_msbit,$t_lsbit) = mask_to_size_lsb_msb($t_mask); # get size,LSB,MSB
            $SIZES{$t_field}  = $t_bitzise ;
            $MSBITS{$t_field} = $t_msbit ;
            $LSBITS{$t_field} = $t_lsbit ;
            $TYPES{$t_field}  = $t_type ;
            $CLOCK_DOMAIN{$t_field}=$t_clock_domain;
            $SHADOW{$t_field} = $t_shadow ;
            $SIGNED{$t_field} = $t_signed ;
            $REG_NAME{$t_field} =$t_field ;
            $ASYNC_RST{$t_field} = $async_reset;
            $t_reset =~ s/0x// ;

            # shift the mask to the lsb
            $t_mask_new = (hex($t_mask) >> $LSBITS{$t_field});
            $t_mask_hex = sprintf "%x", $t_mask_new;

            # Ronen Supports Negative Number: and with the mask register
            $RESET_VALS{$t_field}  = sprintf "%x", (hex(lc(0x.$t_reset)) & hex(lc(0x.$t_mask_hex)));
            $DV_RESET_VALS{$t_field}  = sprintf "%s", $t_reset;
        }


        $INTC_INPUT{$t_field} = $intc_input;
        $INTC_SIG{$t_field}   = $intc_sig;
        $INTC_NAME{$t_field}   = $intc_name;
        $SRST_OUTPUT{$t_field} = $srst_output;
        $SRST_SIG{$t_field}   = $srst_sig;

        if (($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")){
            $synch_regs = 1;
            if (exists $different_clk_domain{$CLOCK_DOMAIN{$t_field}}){
                if (exists $reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}}){
                    if ($srst_output == 0){
                        $reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}} = 0;
                    }
                }
            }
            else{
                $different_clk_domain{$CLOCK_DOMAIN{$t_field}} = $CLOCK_DOMAIN{$t_field};
                $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} = 0;
                if ($srst_output == 1){
                    $reset_different_clk_domain{$CLOCK_DOMAIN{$t_field}} = 1;
                }
            }
            if ( $t_shadow eq "shadow"){
                $shadow_count_tmp = $shadow_count_domain{$CLOCK_DOMAIN{$t_field}};
                $shadow_field_name{$CLOCK_DOMAIN{$t_field}}{$shadow_count_tmp} = $t_field;
                $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} = $shadow_count_domain{$CLOCK_DOMAIN{$t_field}} + 1;
            }
        }
    }
}

# ==========================================
# Creating verilog of reg declarations
open(REG_DEC_FILE, ">$reg_dec_filename") || die "Can't create reg_dec_file $reg_dec_filename\n";
open(IOS_DEC_FILE, ">$outputs_dec_filename") || die "Can't create outputs_dec_file $outputs_dec_filename\n";
open(PAR_DEF_FILE, ">$parameters_def_filename") || die "Can't create parameters_def_file $outputs_dec_filename\n";
open(IOS_LIST_FILE, ">$outputs_list_filename") || die "Can't create outputs_list_file $outputs_list_filename\n";

my $address_map_filename = $opt{module_name}.$address_map_filename_suffix ;
open(ADDRESS_MAP_FILE, ">$opt{sw_mapping_addr_path}/$address_map_filename") || die "Can't create address map file $address_map_filename\n";


if (($opt{gen_test}) && ($opt{host_test})) {
    my $host_test_def_filename   = $opt{module_name}.$host_test_def_file_suffix ;
    my $host_test_WR_RD_FF_filename  = $opt{module_name}.$host_test_WR_RD_FF_file_suffix ;
    my $host_test_WRCNT_filename = $opt{module_name}.$host_test_WRCNT_file_suffix ;
    my $host_test_RDCNT_filename = $opt{module_name}.$host_test_RDCNT_file_suffix ;
    open(HOST_TEST_DEF_FILE, ">$host_test_def_filename") || die "Can't create reg test file $host_test_def_filename\n";
    open(HOST_TEST_WR_RD_FF_FILE, ">$host_test_WR_RD_FF_filename") || die "Can't create reg test file $host_test_WR_RD_FF_filename\n";
    open(HOST_TEST_WRCNT_FILE, ">$host_test_WRCNT_filename") || die "Can't create reg test file $host_test_WRCNT_filename\n";
    open(HOST_TEST_RDCNT_FILE, ">$host_test_RDCNT_filename") || die "Can't create reg test file $host_test_RDCNT_filename\n";
}

#calc the max value of HADDRESSES in order to calc the size of the reg addr range:
my $max_haddr = 0;
foreach my $haddr (keys %HADDRESSES) {
    if ($max_haddr < eval("0x$HADDRESSES{$haddr}")) {
        $max_haddr = eval("0x$HADDRESSES{$haddr }")
    }
}                               #foreach

&insert_header(REG_DEC_FILE);
&insert_header(IOS_DEC_FILE);
&insert_header(IOS_LIST_FILE);
$pulse_found = 0;

$max_reg_length = $max_reg_length + 2 ;
$max_field_length = $max_reg_length + $max_field_length + 3 ;

$reg_number  = 0;

my $block_base_addr;
$block_base_addr = "";

for (@AM_LINES) {
    chomp;
    @TMP = split " ",$_;
    if ((@TMP[1] eq $opt{module_name}) && (@TMP[2] eq $opt{phy_number})) {
        $block_base_addr = @TMP[0];
    }
}

for (@REGS) {
    $t_reg = $_ ;
    printf (REG_DEC_FILE "\t\/\/ Register %s at address %s :\n",$t_reg,$HADDRESSES{$t_reg});
    printf (ADDRESS_MAP_FILE "%s:%s %s",$opt{module_name},$t_reg,$HADDRESSES{$t_reg});

    $first_field = 1;
    $writable_found = 0;

    #used for determing if reserved field is necessary
    $prev_msbits = 0;

    for (@$t_reg) {
        $t_field = $_ ;
        $prev_msbits = $MSBITS{$t_field};

        if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")) {
            $writable_found = 1;
        }
        printf (ADDRESS_MAP_FILE " %s:%s:%d",$t_field,$MASKS_FIELDS{$t_field},$LSBITS{$t_field});


        #************************************************************
        #  HOST TEST
        #************************************************************

        # new version of host tests
        if (($opt{gen_test}) && ($opt{host_test}) && !($AVOID_HOST{$t_reg})) {
            if ((($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")) && ($first_field eq 1)) {
                printf (HOST_TEST_WRCNT_FILE "hyp_write (%s,%x,f) \n", $t_reg,$reg_cnt_test_count);
            }
            if ((($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE"))|(($TYPES{$t_field} eq "RO")&&($RESET_VALS{$t_field} !~ /x/io))) {
                $read_reset_value = hex($RESET_VALS{$t_field}) << $LSBITS{$t_field} ;
                printf (HOST_TEST_DEF_FILE   "hyp_randv (%s, %x, %s, f)\n", $t_reg,$read_reset_value,$MASKS_FIELDS{$t_field});
            }
            if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")) {
                # write to each fiels ff + read ff from field + write back zero + read zero
                $expected_read_val = hex($MASKS_FIELDS{$t_field}) & $reg_cnt_test_count ;
                printf (HOST_TEST_RDCNT_FILE "hyp_randv (%s, %x, %s, f)\n", $t_reg,$expected_read_val,$MASKS_FIELDS{$t_field});
                $expected_read_val = hex($MASKS_FIELDS{$t_field}) & 4294967295 ;
                printf (HOST_TEST_WR_RD_FF_FILE "hyp_write (%s, %x,f) \n", $t_reg,$expected_read_val);
                my $new_expected_read_val = $expected_read_val;
                while (($new_expected_read_val & 1) == 0) {
                    $new_expected_read_val = $new_expected_read_val >> 1;
                }
                printf (HOST_TEST_WR_RD_FF_FILE "hyp_randv (%s, %x, %s, f)\n", $t_reg,$new_expected_read_val,$MASKS_FIELDS{$t_field});
                $expected_read_val = 0x00000000;
                printf (HOST_TEST_WR_RD_FF_FILE "hyp_write (%s, %x,f) \n", $t_reg,$expected_read_val);
                printf (HOST_TEST_WR_RD_FF_FILE "hyp_randv (%s, %x, %s, f)\n", $t_reg,$expected_read_val,$MASKS_FIELDS{$t_field});
            }
        }
        ## Ben moved mctrl inputs from header1 and header2 to here 14/05/2015
        if ($opt{reset_ctrl} == 1) {
            printf (IOS_LIST_FILE "\tmctrl_sw_rst_n,           \/\/ [I] 1b \n",);
            printf (IOS_LIST_FILE "\tmctrl_sw_warm_n_rst_select,           \/\/ [I] 1b \n",);
            printf (IOS_DEC_FILE "\tinput        mctrl_sw_rst_n ;\n");
            printf (IOS_DEC_FILE "\tinput        mctrl_sw_warm_n_rst_select ;\n");
            $opt{reset_ctrl} = 0;
        }
        # Micha added possibility to output wr_pulse 4/11/2010
        if ($opt{wr_pulse_out} == 1) {
            printf (IOS_DEC_FILE "\toutput     wr_pulse          ;\n");
            printf (IOS_LIST_FILE "\twr_pulse,           \/\/ [O] 1b pulse signal\n",);
            $opt{wr_pulse_out} = 0;
        }

        # Micha added PULSED register CBUS cycles extension 26/6/2011
        if ($opt{pulse_addr_ios} == 1) {
            printf (IOS_DEC_FILE "$opt{pulse_addr_inputs}");
            printf (IOS_LIST_FILE "$opt{pulse_addr_ports}");
            $opt{pulse_addr_ios} = 0;
        }

        # Micha added some GCLK related inputs 5/06/2011
        if ($opt{add_gclk_ins} == 1) {
            printf (IOS_DEC_FILE "\tinput     scan_enable          ;\n");
            printf (IOS_DEC_FILE "\tinput     dft_clk_en          ;\n");
            printf (IOS_LIST_FILE "\tscan_enable,           \/\/ [I] 1b \n",);
            printf (IOS_LIST_FILE "\tdft_clk_en,           \/\/ [I] 1b \n",);
            $opt{add_gclk_ins} = 0;
        }

        # ronen added Clear On Read - Udi changed COR to RO_PULSE
        if (($TYPES{$t_field} eq "RO_PULSE") || ($TYPES{$t_field} eq "GUI_R_PULSE")) {
            printf (IOS_DEC_FILE "\toutput     ${t_field}_p          ;\n");
            printf (IOS_LIST_FILE "\t${t_field}_p,           \/\/ [O] 1b pulse signal\n",);
        }

        if ($TYPES{$t_field} eq "PULSE" || $TYPES{$t_field} eq "SINGLE_PULSE") {
            $pulse_found = 1;
        }

        # ronen added shadow enable to list
        if ($SHADOW{$t_field} eq "shadow") {
            printf (IOS_DEC_FILE "\tinput   ${t_field}_shadow_en ;\n");
            printf (IOS_LIST_FILE "\t${t_field}_shadow_en,           \/\/ [I] 1b \n",);
            if ($CLOCK_DOMAIN{$t_field} eq "cbus_rf_clk"){
                ${gclk_en_ored} = "${gclk_en_ored}" . "${t_field}_shadow_en | ";
            }
        }

        if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "WO")||($TYPES{$t_field} eq "PULSE")||($TYPES{$t_field} eq "SINGLE_PULSE")||($TYPES{$t_field} eq "RW_PULSE")||($TYPES{$t_field} eq "RW_INTERNAL")) {
            if ($SIZES{$t_field}>1 && $TYPES{$t_field} ne "SINGLE_PULSE") {  # when SINGLE_PULSE always regard the reg as 1 bit
                if ($TYPES{$t_field} eq "PULSE" || $TYPES{$t_field} eq "SINGLE_PULSE") {
                }                       #  dont define the pulse as a reg
                else {
                    if (($INTC_INPUT{$t_field}) || ($SRST_OUTPUT{$t_field}) || ($SRST_SIG{$t_field})) {
                        printf (REG_DEC_FILE "\treg [%2d:0]        %s"."_reg ;\n", ($SIZES{$t_field}-1), $t_field);
                    } else {
                        printf (REG_DEC_FILE "\treg [%2d-1:0]        %s ;\n", $SIZES{$t_field}, $t_field);
                    }
                }
                if (($t_field =~ "shadow_reg") || $INTC_SIG{$t_field} || ($TYPES{$t_field} eq "RW_INTERNAL")) {
                }                       # dont define as output port
                else {

                    if ($INTC_INPUT{$t_field} && ($TYPES{$t_field} ne "RW_INTERNAL")) {
                        printf (IOS_DEC_FILE "\tinput [%2d:0]         %s ;\n", ($SIZES{$t_field}-1),  $t_field);
                    } else {
                        if (lc(${t_field}) ne "$intc_reset") {    # Udi 25/05/11
                            printf (IOS_DEC_FILE "\toutput [%2d-1:0]        %s ;\n", $SIZES{$t_field},  $t_field);
                            if ($TYPES{$t_field} eq "RW_PULSE") {
                                printf (IOS_DEC_FILE "\toutput                  %s_p ;\n",  $t_field);
                            }
                        }
                    }
                }
            } else {
                if ($TYPES{$t_field} eq "PULSE" || $TYPES{$t_field} eq "SINGLE_PULSE") {
                }                       #  dont define the pulse as a reg
                else {
                    if (($INTC_INPUT{$t_field}) || ($SRST_OUTPUT{$t_field}) || ($SRST_SIG{$t_field})) {
                        printf (REG_DEC_FILE "\treg                 %s"."_reg ;\n", $t_field);
                    } else {
                        printf (REG_DEC_FILE "\treg                 %s ;\n",
                                $t_field);
                    }
                }
                if (($t_field =~ "shadow_reg") || ($INTC_SIG{$t_field}) || ($SRST_SIG{$t_field}) || ($TYPES{$t_field} eq "RW_INTERNAL")) {
                }                       # dont define as output port
                else {
                    if ($INTC_INPUT{$t_field}) {
                        printf (IOS_DEC_FILE "\tinput                  %s ;\n",   $t_field);
                    } else {
                        if (lc(${t_field}) ne "$intc_reset") {    # Udi 25/05/11
                            printf (IOS_DEC_FILE "\toutput                 %s ;\n",   $t_field);
                            if ($TYPES{$t_field} eq "RW_PULSE") {
                                printf (IOS_DEC_FILE "\toutput                 %s_p ;\n",   $t_field);
                            }
                        }
                    }
                }
            }

            if (($t_field =~ "shadow_reg") || ($INTC_SIG{$t_field} eq 1) || ($SRST_SIG{$t_field} eq 1) || ($TYPES{$t_field} eq "RW_INTERNAL") ) {
            }                         # dont define as output port
            else {
                if ($INTC_INPUT{$t_field}) {
                    printf (IOS_LIST_FILE "\t%s,           \/\/ [I] %2dd \n", $t_field, $SIZES{$t_field});
                } else {
                    if (lc(${t_field}) ne "$intc_reset") {    # Udi 25/05/11
                        printf (IOS_LIST_FILE "\t%s,           \/\/ [O] %2dd \n", $t_field, $SIZES{$t_field});
                        if ($TYPES{$t_field} eq "RW_PULSE") {
                            printf (IOS_LIST_FILE "\t%s_p,           \/\/ [O] %2dd \n", $t_field, $SIZES{$t_field});
                        }
                    }
                }
            }
        }

        if (($TYPES{$t_field} eq "CONST")) {
            if ($SIZES{$t_field}>1) {
                printf (REG_DEC_FILE "\twire [%2d-1:0]        %s ;\n",
                        $SIZES{$t_field},
                        $t_field);
                printf (IOS_DEC_FILE "\toutput [%2d-1:0]        %s ;\n",
                        $SIZES{$t_field},
                        $t_field);
            } else {
                printf (REG_DEC_FILE "\twire                 %s ;\n",
                        $t_field);
                printf (IOS_DEC_FILE "\toutput                 %s ;\n",
                        $t_field);
            }
            printf (IOS_LIST_FILE "\t%s,           \/\/ [O] %2dd \n",
                    $t_field,
                    $SIZES{$t_field});
        }
        if (($TYPES{$t_field} eq "RO")||($TYPES{$t_field} eq "RO_PULSE")) {

            if (($INTC_SIG{$t_field})  || ($SRST_SIG{$t_field})) {
            } elsif ($SIZES{$t_field}>1) {
                printf (IOS_DEC_FILE "\tinput [%2d-1:0]         %s ;\n",
                        $SIZES{$t_field},
                        $t_field);
            } else {
                printf (IOS_DEC_FILE "\tinput                  %s ;\n",
                        $t_field);
            }
            if ($INTC_SIG{$t_field}) {
            } else {
                printf (IOS_LIST_FILE "\t%s,           \/\/ [I] %2dd \n",  $t_field,       $SIZES{$t_field});
            }
        }
        if (($first_field eq 1)&&!((($TYPES{$t_field} eq "RO")||($TYPES{$t_field} eq "RO_PULSE")) &&($RESET_VALS{$t_field} =~ /x/i))) {
            $first_field = 0;
        }
    }

    #end reg definition in vr_ad file:
    if ($writable_found > 0) {
        $reg_cnt_test_count = $reg_cnt_test_count + 1 ;
    }

    printf (ADDRESS_MAP_FILE "\n");
    $reg_number += 1;
}


$intc_tmp=0;
foreach $t_intc (@INTC) {
    if ($INTC_ON{$t_intc} eq 1) {
        if ($opt{multy_int} eq "yes"){

            printf (IOS_DEC_FILE "\toutput\t\t\t".$opt{module_name}."_$t_intc"."_out_irq;\n");
            printf (IOS_DEC_FILE "\toutput\t\t\t".$opt{module_name}."_$t_intc"."_out_unmsk_irq;\n");
            printf (IOS_LIST_FILE "\t".$opt{module_name}."_$t_intc"."_out_irq,\n");
            printf (IOS_LIST_FILE "\t".$opt{module_name}."_$t_intc"."_out_unmsk_irq,\n");

            printf ( REG_DEC_FILE"\treg\t\t\t".$opt{module_name}."_$t_intc"."_out_irq;     \n",);
            printf ( REG_DEC_FILE"\treg\t\t\t".$opt{module_name}."_$t_intc"."_out_unmsk_irq; \n   ",);

            printf (IOS_DEC_FILE "\twire\t\t\t".$opt{module_name}."_$t_intc"."_out_irq_sig;\n");
            printf (IOS_DEC_FILE "\twire\t\t\t".$opt{module_name}."_$t_intc"."_out_unmsk_irq_sig;\n");

            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_out_unmsk;\n");
            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_out;\n");
            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_clear_p;\n");
        }
        else{
            if ($intc_tmp<1) {

                #   printf (IOS_LIST_FILE "\t".$opt{module_name}."_$t_intc"."_out_irq,           \/\/ [O] 1b \n",);
                printf (IOS_LIST_FILE "\t".$opt{module_name}."_out_irq,           \/\/ [O] 1b \n",);   #udi changed to an IRQ single output
                printf (IOS_DEC_FILE "\toutput\t\t\t".$opt{module_name}."_out_irq;\n");
                printf (IOS_LIST_FILE "\t".$opt{module_name}."_out_unmsk_irq,           \/\/ [O] 1b \n",);
                printf (IOS_DEC_FILE "\toutput\t\t\t".$opt{module_name}."_out_unmsk_irq;\n");

                printf ( REG_DEC_FILE"\treg\t\t\t".$opt{module_name}."_out_irq;     \n",);
                printf ( REG_DEC_FILE"\treg\t\t\t".$opt{module_name}."_out_unmsk_irq; \n   ",);

            }
            printf (IOS_DEC_FILE "\twire\t\t\t".$opt{module_name}."_$t_intc"."_out_irq;\n");
            printf (IOS_DEC_FILE "\twire\t\t\t".$opt{module_name}."_$t_intc"."_out_unmsk_irq;\n");

            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_out_unmsk;\n");
            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_out;\n");
            printf (REG_DEC_FILE "  wire [".$INTC_MSBIT{$t_intc}.":0] ".$opt{module_name}."_$t_intc"."_clear_p;\n");

            $intc_tmp+=1;
        }
    }
}

if ($synch_regs == 1){
    print Dumper(\%different_clk_domain);
    foreach $element(keys %different_clk_domain){
        print "element = $element \n";
        print Dumper \@$opt;
        if ($element ne $opt{intc_clk_name}){

            if (exists $reset_different_clk_domain{$element}){
                if ($reset_different_clk_domain{$element} == 0){
                    printf (IOS_DEC_FILE "\tinput \[3:0\]\t\t$element\_$opt{module_name}_rf_clk_ratio   \;\n");
                    printf (IOS_LIST_FILE "\t$element\_$opt{module_name}_rf_clk_ratio,           \/\/ [I] 4d \n");
                }
            }
            else {
                printf (IOS_DEC_FILE "\tinput \[3:0\]\t\t$element\_$opt{module_name}_rf_clk_ratio   \;\n");
                printf (IOS_LIST_FILE "\t$element\_$opt{module_name}_rf_clk_ratio,           \/\/ [I] 4d \n");
            }
            if ($element ne $opt{intc_clk_name}){
                printf (IOS_DEC_FILE "\tinput \t\t$element\;\n");
                printf (IOS_LIST_FILE "\t$element\,           \/\/ [I] 1d \n");
            }

            printf (IOS_DEC_FILE "\tinput \t\t$element\_rcg_reset_n\;\n");
            printf (IOS_LIST_FILE "\t$element\_rcg_reset_n\,           \/\/ [I] 1d \n");
            if (exists $reset_different_clk_domain{$element}){
                if ($reset_different_clk_domain{$element} == 0){
                    printf (REG_DEC_FILE "\twire $element\_phase\;\n");
                }
            }
            else{

                printf (REG_DEC_FILE "\twire $element\_phase\;\n");

            }
        }
    }
}

if (($opt{intc_clk_name} ne "rf_clk") and @INTC) {
    printf (IOS_DEC_FILE "\tinput \t\t$opt{intc_clk_name}\;\n");
    printf (IOS_LIST_FILE "\t$opt{intc_clk_name}\,           \/\/ [I] 1d \n");
    printf (IOS_DEC_FILE "\tinput \[3:0\]\t\t$opt{intc_clk_name}\_$opt{module_name}_rf_clk_ratio   \;\n");
    printf (IOS_LIST_FILE "\t$opt{intc_clk_name}\_$opt{module_name}_rf_clk_ratio,           \/\/ [I] 4d \n");
    printf (IOS_DEC_FILE "\tinput \t\t$opt{intc_clk_name}\_rcg_reset_n\;\n");
    printf (IOS_LIST_FILE "\t$opt{intc_clk_name}\_rcg_reset_n\,           \/\/ [I] 1d \n");
    printf (REG_DEC_FILE "\twire $opt{intc_clk_name}\_phase\;\n");

}
printf (REG_DEC_FILE "\twire gclk;\n");

#ben signals for rd/wr intc
my $rd_err_p = "rd_err_p_".$opt{rd_wr_intc_name};
my $wr_err_p = "wr_err_p_".$opt{rd_wr_intc_name};

printf (REG_DEC_FILE "\treg [ADD_DW-1:0] $opt{module_name}_bad_rd_addr;\n");
printf (REG_DEC_FILE "\treg [ADD_DW-1:0] $opt{module_name}_bad_wr_addr;\n");
# printf (REG_DEC_FILE "\treg $rd_err_p;\n");
# printf (REG_DEC_FILE "\treg $wr_err_p;\n");

printf (REG_DEC_FILE "\t\/\/===============================================\n");
printf (REG_DEC_FILE "\n");
printf (IOS_DEC_FILE "\t\/\/===============================================\n");
printf (IOS_DEC_FILE "\n");
printf (IOS_LIST_FILE "\t\/\/===============================================\n");
printf (IOS_LIST_FILE "\n");

printf (PAR_DEF_FILE "\nlocalparam ADD_DW = %d;\n",$opt{aw});

close (PAR_DEF_FILE);
close (REG_DEC_FILE);
close (IOS_DEC_FILE);
close (IOS_LIST_FILE);
close (ADDRESS_MAP_FILE);


if ($opt{gen_test} && ($opt{host_test})) {
    close (HOST_TEST_DEF_FILE);
    close (HOST_TEST_WR_RD_FF_FILE);
    close (HOST_TEST_WRCNT_FILE);
    close (HOST_TEST_RDCNT_FILE);
}

# ==========================================
# Creating verilog of write / read logic seperate
# first the write logic
open(WR_RD_LOGIC_FILE, ">$rw_logic_filename") || die "Can't create rw_logic_filename \n";
&insert_header(WR_RD_LOGIC_FILE);
printf (WR_RD_LOGIC_FILE "\t\/\/ write logic\n");
printf (WR_RD_LOGIC_FILE "\t\/\/ ---------------\n");

####creating phase for each frequency
if ($synch_regs == 1)  {
    foreach $element(keys %different_clk_domain){
        if($element ne $opt{intc_clk_name}){

            if (exists $reset_different_clk_domain{$element}){
                if ($reset_different_clk_domain{$element} == 0){
                    printf (WR_RD_LOGIC_FILE "\n\n   \/\/$element phase ");
                    printf (WR_RD_LOGIC_FILE "\n\t   phase_generator $element\_phase_generator_i \(");
                    printf (WR_RD_LOGIC_FILE "\n\t   \/\/inputs ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk          \($opt{clock}\),  ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk_reset_n   \($opt{reset}\),  ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk           \($element\),  ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk_reset_n   \($element\_rcg_reset_n\),  ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .domains_ratio   \($element\_$opt{module_name}_rf_clk_ratio\),  ");
                    printf (WR_RD_LOGIC_FILE "\n\t   \/\/outputs ");
                    printf (WR_RD_LOGIC_FILE "\n\t       .phase   \($element\_phase\)\);  ");
                }
            }
            else {
                printf (WR_RD_LOGIC_FILE "\n\n   \/\/$element phase ");
                printf (WR_RD_LOGIC_FILE "\n\t   phase_generator $element\_phase_generator_i \(");
                printf (WR_RD_LOGIC_FILE "\n\t   \/\/inputs ");
                printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk          \($opt{clock}\),  ");
                printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk_reset_n   \($opt{reset}\),  ");
                printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk           \($element\),  ");
                printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk_reset_n   \($element\_rcg_reset_n\),  ");
                printf (WR_RD_LOGIC_FILE "\n\t       .domains_ratio   \($element\_$opt{module_name}_rf_clk_ratio\),  ");
                printf (WR_RD_LOGIC_FILE "\n\t   \/\/outputs ");
                printf (WR_RD_LOGIC_FILE "\n\t       .phase   \($element\_phase\)\);  ");
            }
        }
    }
}
## creating intc_clk phase
if ($opt{intc_clk_name} ne "rf_clk"){

    printf (WR_RD_LOGIC_FILE "\n\n   \/\/$opt{intc_clk_name} phase ");
    printf (WR_RD_LOGIC_FILE "\n\t   phase_generator $opt{intc_clk_name}\_phase_generator_i \(");
    printf (WR_RD_LOGIC_FILE "\n\t   \/\/inputs ");
    printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk          \($opt{clock}\),  ");
    printf (WR_RD_LOGIC_FILE "\n\t       .slow_clk_reset_n   \($opt{reset}\),  ");
    printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk           \($opt{intc_clk_name}\),  ");
    printf (WR_RD_LOGIC_FILE "\n\t       .fast_clk_reset_n   \($opt{intc_clk_name}\_rcg_reset_n\),  ");
    printf (WR_RD_LOGIC_FILE "\n\t       .domains_ratio   \($opt{intc_clk_name}\_$opt{module_name}_rf_clk_ratio\),  ");
    printf (WR_RD_LOGIC_FILE "\n\t   \/\/outputs ");
    printf (WR_RD_LOGIC_FILE "\n\t       .phase   \($opt{intc_clk_name}\_phase\)\);  ");

}

my $max_iaddress = "ADD_DW'h0";
for (@REGS) {

    $t_reg = $_ ;
    for (@$t_reg) {
        $t_field = $_ ;

        if($t_field eq "intc_sreset_n") {

        }
        if (($INTC_INPUT{$t_field})  || ($SRST_SIG{$t_field}) || ($SRST_OUTPUT{$t_field})) {
            $t_field_name = "$t_field"."_reg";
        } else {
            $t_field_name = $t_field;
        }

        $max_iaddress = $IADDRESSES{$t_reg};

        ### constant values
        printf (WR_RD_LOGIC_FILE "\n");
        if ($TYPES{$t_field} eq "CONST") {
            printf (WR_RD_LOGIC_FILE "\tassign %s\ = %d\'h%s ;\n",
                    $t_field,
                    $SIZES{$t_field},
                    $RESET_VALS{$t_field});
        }

        ## delte pulse from registers will be defined as wire
        elsif (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")||($TYPES{$t_field} eq "WO")||($TYPES{$t_field} eq "RW_INTERNAL")) {
            if (($SHADOW{$t_field} eq "shadow") & ($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")){



                if ( $ASYNC_RST{$t_field} eq "Yes"){
                    printf (WR_RD_LOGIC_FILE "\talways \@\(posedge gclk_$CLOCK_DOMAIN{$t_field} or negedge  $CLOCK_DOMAIN{$t_field}\_reset_n\)\n");
                }
                else{
                    printf (WR_RD_LOGIC_FILE "\n\talways \@\(posedge  gclk_$CLOCK_DOMAIN{$t_field}\)\n");
                }
                printf (WR_RD_LOGIC_FILE "\tif \(~$CLOCK_DOMAIN{$t_field}\_rcg_reset_n\)\n");
                printf (WR_RD_LOGIC_FILE "\t\t%s\ <= %d\'h%s ;\n", $t_field_name, $SIZES{$t_field}, $RESET_VALS{$t_field});
                printf (WR_RD_LOGIC_FILE "\telse if \(%s \& ~%s\ \& \(%s\[ADD_DW-1:2\] == %s'h%s\) & \($CLOCK_DOMAIN{$t_field}\_phase\)\)\n",
                        $opt{cs},
                        $opt{r_wn},
                        $opt{address},
                        $aw_trunc,
                        $IADDRESSES{$t_reg});
            }
            else{

                if ($ASYNC_RST{$t_field} eq "Yes"){
                    printf (WR_RD_LOGIC_FILE "\talways \@\(posedge $opt{gclock} or negedge $opt{reset} \)\n");
                }
                else {
                    ## Reset Value
                    printf (WR_RD_LOGIC_FILE "\n\talways \@\(posedge %s\)\n", $opt{gclock});
                }
                printf (WR_RD_LOGIC_FILE "\tif \(~%s\)\n",$opt{reset});
                printf (WR_RD_LOGIC_FILE "\t\t%s\ <= %d\'h%s ;\n", $t_field_name, $SIZES{$t_field}, $RESET_VALS{$t_field});
                printf (WR_RD_LOGIC_FILE "\telse if \(%s \& ~%s\ \& \(%s\[ADD_DW-1:2\] == %s'h%s\)\)\n",
                        $opt{cs},
                        $opt{r_wn},
                        $opt{address},
                        $aw_trunc,
                        $IADDRESSES{$t_reg});
            }
        }

        if (($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE")||($TYPES{$t_field} eq "WO")||($TYPES{$t_field} eq "RW_INTERNAL")) {
            if ($SIZES{$t_field} ne "1") {
                printf (WR_RD_LOGIC_FILE "\t\t %s \<= %s\[%d:%d\] ;\n",
                        $t_field_name,
                        $opt{data},
                        $MSBITS{$t_field},
                        $LSBITS{$t_field}); # REG <= arb_dat[7:0]
            } else {
                printf (WR_RD_LOGIC_FILE "\t\t %s \<= %s\[%d\] ;\n",
                        $t_field_name,
                        $opt{data},
                        $LSBITS{$t_field}); # REG <= arb_dat[4]
            }
        }
        if ($TYPES{$t_field} eq "PULSE" || $TYPES{$t_field} eq "SINGLE_PULSE") {

            if (($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")  ){

                if ($TYPES{$t_field} eq "SINGLE_PULSE") {
                    #ben: we drop lsbs in the reg file now
                    printf (WR_RD_LOGIC_FILE "\t assign  %s =  \(\(wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s )) & $CLOCK_DOMAIN{$t_field}\_phase\);\/\/ Signal is a single pulse \n",
                            $t_field_name,
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                } elsif ($SIZES{$t_field} eq "1") {
                    printf (WR_RD_LOGIC_FILE "\t assign  %s = ( (%s\[%d\] & wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s ))  & $CLOCK_DOMAIN{$t_field}\_phase\);\/\/ Signal is a pulse \n",
                            $t_field_name,
                            $opt{data},
                            $LSBITS{$t_field},
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                } else {
                    printf (WR_RD_LOGIC_FILE "\t assign %s\[%d:0\] =   ((%s\[%d:%d\] \& \{%d\{(wr_pulse & %s\[ADD_DW-1:2\]\ == %s'h%s )\}\}) & \{$SIZES{$t_field}\{$CLOCK_DOMAIN{$t_field}\_phase\}\}\)\;\/\/ Signal is a pulse\n",
                            $t_field_name,
                            $SIZES{$t_field}-1,
                            $opt{data},
                            $MSBITS{$t_field},
                            $LSBITS{$t_field},
                            $SIZES{$t_field},
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                }
            }

            else {
                if ($TYPES{$t_field} eq "SINGLE_PULSE") {
                    printf (WR_RD_LOGIC_FILE "\t assign  %s =  (wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s ));\/\/ Signal is a single pulse \n",
                            $t_field_name,
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                } elsif ($SIZES{$t_field} eq "1") {
                    printf (WR_RD_LOGIC_FILE "\t assign  %s =  (%s\[%d\] & wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s ));\/\/ Signal is a pulse \n",
                            $t_field_name,
                            $opt{data},
                            $LSBITS{$t_field},
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                } else {
                    printf (WR_RD_LOGIC_FILE "\t assign %s\[%d:0\] =   (%s\[%d:%d\] \& \{%d\{(wr_pulse & %s\[ADD_DW-1:2\]\ == %s'h%s )\}\});\/\/ Signal is a pulse\n",
                            $t_field_name,
                            $SIZES{$t_field}-1,
                            $opt{data},
                            $MSBITS{$t_field},
                            $LSBITS{$t_field},
                            $SIZES{$t_field},
                            $opt{address},
                            $aw_trunc,
                            $IADDRESSES{$t_reg});
                }
            }

        }

        # ronen added shadow latch

        if (($SHADOW{$t_field} eq "shadow")) {
            printf (WR_RD_LOGIC_FILE "\t else if (${t_field}_shadow_en)\n");
            if ($SIZES{$t_field} eq "1") {
                printf (WR_RD_LOGIC_FILE "\t   $t_field_name <= $t_field_name\_shadow_reg;\n");
            } else {

                # in case that we have severals shaodow in the same field same address few shadow reg
                printf (WR_RD_LOGIC_FILE "\t   $t_field_name <= $t_field_name\_shadow_reg\[%d:0\]\;\n",
                        $MSBITS{$t_field} - $LSBITS{$t_field});
            }
        }
    }
}

printf (WR_RD_LOGIC_FILE "\n\talways \@\(posedge %s\)\n", $opt{gclock});
printf (WR_RD_LOGIC_FILE "\tif \(~%s\)\n",$opt{reset});
printf (WR_RD_LOGIC_FILE "\tbegin \n");
printf (WR_RD_LOGIC_FILE "\t\t$opt{module_name}_bad_wr_addr[ADD_DW-1:0] <= {ADD_DW{1'b0}} ; \n");
printf (WR_RD_LOGIC_FILE "\tend \n");
printf (WR_RD_LOGIC_FILE "\telse if \(%s \& ~%s & \(%s[ADD_DW-1:2] \> %d'h$max_iaddress\)\)\n",
        $opt{cs},
        $opt{r_wn},
        $opt{address},
        $aw_trunc);
printf (WR_RD_LOGIC_FILE "\tbegin \n");

printf (WR_RD_LOGIC_FILE "\t\t$opt{module_name}_bad_wr_addr[ADD_DW-1:0] <= %s[ADD_DW-1:0] ; \n", $opt{address});

printf (WR_RD_LOGIC_FILE "\tend \n");

#ben $wr_err_pulse generate
# printf (WR_RD_LOGIC_FILE "\n\talways \@\(posedge %s\)\n", $opt{gclock});
# printf (WR_RD_LOGIC_FILE "\tif \(~%s\)\n",$opt{reset});
# printf (WR_RD_LOGIC_FILE "\tbegin \n");
# printf (WR_RD_LOGIC_FILE "\t\t$wr_err_p\ <= 1'b0 ;\n");
# printf (WR_RD_LOGIC_FILE "\tend \n");
# printf (WR_RD_LOGIC_FILE "\telse if \(%s \& ~%s & \(%s[ADD_DW-1:2] \> %d'h$max_iaddress\)\)\n",
#         $opt{cs},
#         $opt{r_wn},
#         $opt{address},
#         $aw_trunc);
# printf (WR_RD_LOGIC_FILE "\tbegin \n");

# printf (WR_RD_LOGIC_FILE "\t\t$wr_err_p <= 1'b1 ; \n");
# printf (WR_RD_LOGIC_FILE "\tend \n");
# printf (WR_RD_LOGIC_FILE "\telse $wr_err_p <= 1'b0 ; \n");

printf (WR_RD_LOGIC_FILE "\n\t\/\/ -------------------\n");
printf (WR_RD_LOGIC_FILE "\t\/\/ Read/Write pulse logic\n");
printf (WR_RD_LOGIC_FILE "\t\/\/ -------------------");

for (@REGS) {
    $t_reg = $_ ;
    for (@$t_reg) {
        $t_field = $_ ;
        if (($TYPES{$t_field} eq "RO_PULSE") || ($TYPES{$t_field} eq "GUI_R_PULSE")) {

            if (($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")){
                printf (WR_RD_LOGIC_FILE "\n\tassign ${t_field}_p = (rd_pulse & \(%s\[ADD_DW-1:2\]\ == 'h%s )) & $CLOCK_DOMAIN{$t_field}\_phase;",
                        $opt{address},
                        $IADDRESSES{$t_reg});
            }
            else {
                printf (WR_RD_LOGIC_FILE "\n\tassign ${t_field}_p = rd_pulse & \(%s\[ADD_DW-1:2\]\ == 'h%s );",
                        $opt{address},
                        $IADDRESSES{$t_reg});
            }
        } elsif ($TYPES{$t_field} eq "RW_PULSE") {
            if (($CLOCK_DOMAIN{$t_field} ne "cbus_rf_clk") && ($CLOCK_DOMAIN{$t_field} ne "rf_clk")){
                printf (WR_RD_LOGIC_FILE "\n\tassign ${t_field}_p = (wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s)) & $CLOCK_DOMAIN{$t_field}\_phase;",
                        $opt{address},
                        $aw_trunc,
                        $IADDRESSES{$t_reg});
            }
            else {
                printf (WR_RD_LOGIC_FILE "\n\tassign ${t_field}_p = wr_pulse & \(%s\[ADD_DW-1:2\]\ == %s'h%s );",
                        $opt{address},
                        $aw_trunc,
                        $IADDRESSES{$t_reg});
            }
        }
    }
}


printf (WR_RD_LOGIC_FILE "\n\n\t\/\/ ---------------\n");
printf (WR_RD_LOGIC_FILE "\t\/\/ read mux logic\n");
printf (WR_RD_LOGIC_FILE "\t\/\/ ---------------\n");
printf (WR_RD_LOGIC_FILE "\talways \@\(posedge %s\)\n",
        $opt{gclock});
printf (WR_RD_LOGIC_FILE "\tif \(~%s\)\n\tbegin\n",$opt{reset}); #,$opt{dw});
printf (WR_RD_LOGIC_FILE              "\t\t%s <= {$opt{dw}\{1\'b0\}\} ;\n",$opt{dat_out}); #,$opt{dw});
printf (WR_RD_LOGIC_FILE              "\t\t$opt{module_name}_bad_rd_addr[ADD_DW-1:0] <= {ADD_DW{1'b0}} ;\n",$opt{reset},$opt{dat_out}); #,$opt{dw});
# printf (WR_RD_LOGIC_FILE              "\t\t$rd_err_p <= 1'b0 ;\n",$opt{reset},$opt{dat_out}); #,$opt{dw});
printf (WR_RD_LOGIC_FILE "\tend\n"); #,$opt{dw});

printf (WR_RD_LOGIC_FILE "\telse if \(%s \& %s\)\n",
        $opt{cs},
        $opt{r_wn});

## set the rdata to zeros default values
printf (WR_RD_LOGIC_FILE "\tbegin \n\t\t%s <=\{$opt{dw}\{1\'b0\}\} ;\n",
        $opt{dat_out});
# printf (WR_RD_LOGIC_FILE "\t\t$rd_err_p <= 1'b0 ;\n");

printf (WR_RD_LOGIC_FILE "\t\tcase \(%s\[ADD_DW-1:2\]\)\n",$opt{address});

for (@REGS) {
    $t_reg = $_ ;
    $tmp = $#$t_reg ;
    if ($tmp > 0) {
        printf (WR_RD_LOGIC_FILE "\t\t\t$aw_trunc\'h%s:\n\t\t\tbegin\n",
                #$opt{aw},
                $IADDRESSES{$t_reg}); # 6'h24: begin
        for (@$t_reg) {
            $t_field = $_ ;

            if (($INTC_INPUT{$t_field})  || ($SRST_SIG{$t_field}) ||  ($SRST_OUTPUT{$t_field})) {
                $t_field_name = "$t_field"."_reg";
            } else {
                $t_field_name = $t_field;
            }

            if ((($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE"))||($TYPES{$t_field} eq "R")||($TYPES{$t_field} eq "RO") ||($TYPES{$t_field} eq "RO_PULSE") || ($TYPES{$t_field} eq "RO_INTERNAL") || ($TYPES{$t_field} eq "RW_INTERNAL") ) {
                if ($SIZES{$t_field} ne "1"){
                    printf (WR_RD_LOGIC_FILE "\t\t\t\t%s\[%d:%d\] \<= %s\[%d:%d\] ;\n",
                            $opt{dat_out},
                            $MSBITS{$t_field},
                            $LSBITS{$t_field},
                            $t_field_name,
                            $MSBITS{$t_field} - $LSBITS{$t_field},
                            $LSBITS{$t_field} - $LSBITS{$t_field}); # dat_out[7:0] <= REG
                } else {
                    printf (WR_RD_LOGIC_FILE "\t\t\t\t%s\[%d\] \<= %s ;\n",
                            $opt{dat_out},
                            $LSBITS{$t_field},
                            $t_field_name,
                            $LSBITS{$t_field}); # dat_out[4] <= REG
                }
            }
        }
        printf (WR_RD_LOGIC_FILE "\t\t\tend\n");
    } else {
        $t_field = @$t_reg[0] ;

        if (($INTC_INPUT{$t_field})  || ($SRST_SIG{$t_field}) || ($SRST_OUTPUT{$t_field})) {
            $t_field_name = "$t_field"."_reg";
        } else {
            $t_field_name = $t_field;
        }
        ## Ronen added sign extension

        if ((($TYPES{$t_field} eq "RW")||($TYPES{$t_field} eq "RW_PULSE"))||($TYPES{$t_field} eq "R")||($TYPES{$t_field} eq "RO")||($TYPES{$t_field} eq "RO_PULSE") || ($TYPES{$t_field} eq "RO_INTERNAL")) {
            if (($SIZES{$t_field} ne "1")&&($SIZES{$t_field} ne "32")&&($SIGNED{$t_field} eq "Signed")) {
                printf (WR_RD_LOGIC_FILE "\t \/\/ Signed Extension \n");
                printf (WR_RD_LOGIC_FILE "\t\t\t$aw_trunc\'h%s: %s\[%d-1:%d\] \<= {{(%d-1-%d){%s[%d]}},{%s\[%d:%d\]}} ;\n",
                        $IADDRESSES{$t_reg},
                        $opt{dat_out},
                        $opt{dw},
                        $LSBITS{$t_field},
                        $opt{dw},
                        $MSBITS{$t_field},
                        $t_field_name,
                        $MSBITS{$t_field},
                        $t_field_name,
                        $MSBITS{$t_field} - $LSBITS{$t_field},
                        $LSBITS{$t_field} - $LSBITS{$t_field});
            } # 6'h23: dat_out[7:0] <= REG
            elsif ($SIZES{$t_field} ne "1") {
                printf (WR_RD_LOGIC_FILE "\t\t\t$aw_trunc\'h%s: %s\[%d:%d\] \<= %s\[%d:%d\] ;\n",
                        #$opt{aw},
                        $IADDRESSES{$t_reg},
                        $opt{dat_out},
                        $MSBITS{$t_field},
                        $LSBITS{$t_field},
                        $t_field_name,
                        $MSBITS{$t_field} - $LSBITS{$t_field},
                        $LSBITS{$t_field} - $LSBITS{$t_field});} # 6'h23: dat_out[7:0] <= REG
            else {
                printf (WR_RD_LOGIC_FILE "\t\t\t$aw_trunc\'h%s: %s\[%d\] \<= %s ;\n",
                        $IADDRESSES{$t_reg},
                        $opt{dat_out},
                        $LSBITS{$t_field},
                        $t_field_name,
                        $LSBITS{$t_field});
            } # 6'h23: dat_out[4] <= REG
        }
    }
}

#Ben added illegal_rd_addr sample
printf (WR_RD_LOGIC_FILE "\t\t\tdefault: \n");
printf (WR_RD_LOGIC_FILE "\t\t\tbegin\n");
printf (WR_RD_LOGIC_FILE "\t\t\t\t%s <= %d\'hBABADBAD ;\n",$opt{dat_out},$opt{dw});
printf (WR_RD_LOGIC_FILE "\t\t\t\t$opt{module_name}_bad_rd_addr[ADD_DW-1:0] <= %s[ADD_DW-1:0\];\n",$opt{address});
# printf (WR_RD_LOGIC_FILE "\t\t\t\t$rd_err_p <= 1'b1;\n",$opt{address});
printf (WR_RD_LOGIC_FILE "\t\t\tend\n");
printf (WR_RD_LOGIC_FILE "\t\tendcase\n\tend \n");
printf (WR_RD_LOGIC_FILE "\telse\n\tbegin\n");

printf (WR_RD_LOGIC_FILE "\t\t%s <= %d\'h0 ;\n",$opt{dat_out},$opt{dw});
# printf (WR_RD_LOGIC_FILE "\t\t$rd_err_p <= 1'b0 ;\n");
printf (WR_RD_LOGIC_FILE "\tend\n");

# ==========================================
printf (WR_RD_LOGIC_FILE "\n");
close (WR_RD_LOGIC_FILE);

# ==========================================
# Creating gate clock logic
open(CG_LOGIC_FILE, ">$clock_gate_filename") || die "Can't create clock_gate_filename \n";
&insert_header(CG_LOGIC_FILE);

printf (CG_LOGIC_FILE "\n");
printf (CG_LOGIC_FILE " /////////////////////////////////////////// CLOCK GATING /////////////////////////////////////////// \n");
printf (INTC_LOGIC_FILE "\n\twire gclk_en;\n");

#ben remarked i have no idea what this does and i need gclk_en
${gclk_en_ored} = "\tassign gclk_en = " . "${gclk_en_ored}" . "cbus_slv_cfg_req;\n";
printf (CG_LOGIC_FILE "\t${gclk_en_ored}\n");

printf (CG_LOGIC_FILE "   cluster_clock_gating reg_file_gclk_i (\n");
printf (CG_LOGIC_FILE "\t\t// Outputs\n");
printf (CG_LOGIC_FILE "\t\t.clk_o      (".$opt{gclock}."),         // Output gated clock \n");
printf (CG_LOGIC_FILE "\t\t// Inputs\n");
printf (CG_LOGIC_FILE "\t\t.clk_i      (".$opt{clock}."),\n");
printf (CG_LOGIC_FILE "\t\t.en_i       (gclk_en),      // RegFile clock gating signal \n");
printf (CG_LOGIC_FILE "\t\t.test_en_i  (scan_enable));\n\n");
# ==========================================

exit 0;

sub mask_to_size_lsb_msb {
    my $hmask;
    my $mask;
    my $tmp_mask;
    my $bitsize;
    my $lsbit;
    my $msbit;
    my $bit31 ;
    my $f = 0 ;

    $hmask = shift ;
    $mask = hex($hmask);
    $bit31 = $mask & 2147483648 ;
    $bit31 = $bit31 >> 31 ;
    $lsbit = 0 ;
    $bitsize = 1;

    # look for the LSB by looking for the first bit == 1
    $mask = $mask << 1;
    do { $mask = $mask >> 1;
         $f = 1 ;
         $tmp_mask = ($mask >> 1) << 1 ;
         $lsbit += 1 ;
    } while ( $tmp_mask == $mask ) ;
    $lsbit -= 1 ;
    $msbit = $lsbit ;
    # look for the MSB
    do { $mask = $mask >> 1;
         $tmp_mask = ($mask >> 1) << 1 ;
         $msbit += 1 ;
    } while ( $tmp_mask != $mask ) ;
    $bitzise = $msbit - $lsbit ;
    $msbit -= 1;
    return ($bitzise,$msbit,$lsbit)
}

sub shlof_bitim {
    my $hvalue = shift ;
    my $lsbits   = shift ;
    my $width = shift ;
    my $mask = 2**$width - 1;
    $hvalue = hex($hvalue);
    $hvalue = $hvalue >> $lsbits ;
    $hvalue = $hvalue & $mask ;
    $hvalue = sprintf "%lx",$hvalue ;
    return ($hvalue);
}

##************************************************************
##  Sets tha max width of the registers
##************************************************************
sub get_max_reg_width {
    $max_reg_width = 0;
    for (@REGS) {
        $t_reg = $_;
        for (@$t_reg) {
            $t_field = $_;
            if (($TYPES{$t_field} ne "RO")||($TYPES{$t_field} eq "RO_PULSE")) {
                if ($SIZES{$t_field} > $max_reg_width) {
                    $max_reg_width  = $SIZES{$t_field};
                }
            }
        }
    }
    return ($max_reg_width - 1);
}

##************************************************************
##  Inserts header file
##************************************************************
sub insert_header {
    $fid = $_;

    #    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    #
    #    open(fid1,  $header_file) || die "Can't open $header_file \n";
    #    for (<fid1>) {
    #        printf(fid "$_") ;
    #    }
    #    $mon  += 1;
    #    $year += 1900;
    #    if ($hour < 10) { $hour = "0" . $hour; }
    #    if ($min  < 10) { $min  = "0" . $min;  }
    #    if ($sec  < 10) { $sec  = "0" . $sec;  }
    #    printf (fid "\n\/*************************************************************\n");
    #    printf (fid " * Automatically created by gen_regfile_hdl script\n");
    #    printf (fid " * At: $mday-$mon-$year $hour:$min:$sec\n");
    #    printf (fid " *************************************************************\/\n\n");
}
