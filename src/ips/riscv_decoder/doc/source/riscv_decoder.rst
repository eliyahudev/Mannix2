.. sectnum::

.. toctree::
   :maxdepth: 2

.. header:: `Decoder`

The decoder used to generate control signals as a function of the incoming instruction.

###########################################################################
Module
###########################################################################

***************************************************************************
Parameters
***************************************************************************
The decoder block is a parametrized RTL module.

.. table:: Decoder RTL external parameters

  +----------------------+-------+---------------------------------------+
  | Name                 | Value | Purpose                               |
  +======================+=======+=======================================+
  | FPU                  | 0     | Floating Point arithmetic support     |
  +----------------------+-------+---------------------------------------+
  | PULP_SECURE          | 0     | ???                                   |
  +----------------------+-------+---------------------------------------+
  | SHARED_FP            | 0     | Irrelevant when FPU is not applicable |
  +----------------------+-------+---------------------------------------+
  | SHARED_DSP_MULT      | 0     | No shared multiplier                  |
  +----------------------+-------+---------------------------------------+
  | SHARED_INT_DIV       | 0     | No shared divider                     |
  +----------------------+-------+---------------------------------------+
  | SHARED_FP_DIVSQRT	 | 2     | Irrelevant when FPU is not applicable |
  +----------------------+-------+---------------------------------------+
  | WAPUTYPE             | 0     | N/A without FPU                       |
  +----------------------+-------+---------------------------------------+
  | APU_WOP_CPU          | 6     | N/A without FPU                       |
  +----------------------+-------+---------------------------------------+


***************************************************************************
Constants
***************************************************************************
There are few constants, which define the modules I/F:

.. table:: Decoder RTL constants

  +--------------+-------+-------------------------+
  | Name         | Value | Purpose                 |
  +==============+=======+=========================+
  | ALU_OP_WIDTH |     7 | Width of the ALU opcode |
  +--------------+-------+-------------------------+
  | C_CMD        |     4 | Irrelevant without FPU  |
  +--------------+-------+-------------------------+

***************************************************************************
Input ports
***************************************************************************

.. table:: Decoder input ports

           +----------------------------+-------------------------+------------------------------------------------+
           | Name                       | Source                  | Purpose                                        |
           +============================+=========================+================================================+
           | ``deassert_we_i``          | Controller (ID)         | De-assert write enable for next instruction    |
           +----------------------------+-------------------------+------------------------------------------------+
           | ``data_misaligned_i``      | LSU (WB)                | Data misalignment access indicator             |
           +----------------------------+-------------------------+------------------------------------------------+
           | ``mult_multicycle_i``      | Multiplier (EX)         | Multiplier's multi-cycle calculation indicator |
           +----------------------------+-------------------------+------------------------------------------------+
           | ``illegal_c_insn_i``       | Compressed decoder (IF) | Illegal C instruction indicator                |
           +----------------------------+-------------------------+------------------------------------------------+
           | ``current_priv_lvl_i``     | CSR (EX)                | Current privilege level                        |
           +----------------------------+-------------------------+------------------------------------------------+
           | ``instr_rdata_i[31:0]``    | Compressed decoder (IF) | Extended 32b instruction data                  |
           +----------------------------+-------------------------+------------------------------------------------+

***************************************************************************
Output ports
***************************************************************************
Not all of the output ports are applicable or present, it depends on several parameters. Therefore we categorize them in applicable *vs.* inapplicable tables.

Inapplicable output ports
---------------------------------------------------------------------------

.. table:: Decoder inapplicable output ports

           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | Name                                  | Destination                                                  | Purpose                                      |
           +=======================================+==============================================================+==============================================+
           | ``reg_fp_a_o``                        | Controller (ID) via comparators + 6th address bit of RegFile | FP register A used - inapplicable without FP |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``reg_fp_b_o``                        | Controller (ID) via comparators + 6th address bit of RegFile | FP register B used - inapplicable without FP |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``reg_fp_c_o``                        | Controller (ID) via comparators + 6th address bit of RegFile | FP register C used - inapplicable without FP |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``reg_fp_d_o``                        | Controller (ID) via comparators + 6th address bit of RegFile | FP register D used - inapplicable without FP |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``fpu_op_o[C_CMD-1:0]``               | N/A                                                          | N/A                                          |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``apu_en_o``                          | Controller (ID) + ALU FW logic (EX)                          | N/A without FPU                              |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``apu_type_o[WAPUTYPE-1:0]``          | N/A                                                          | Absent for WAPUTYPE=0                        |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``apu_op_o[APU_WOP_CPU-1:0]``         | N/A                                                          | N/A without FPU                              |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``apu_lat_o``                         | N/A                                                          | N/A without FPU                              |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``apu_flags_src_o[WAPUTYPE-1:0]``     | N/A                                                          | Absent for WAPUTYPE=0                        |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+
           | ``fp_rnd_mode_o``                     | N/A                                                          | N/A without FPU                              |
           +---------------------------------------+--------------------------------------------------------------+----------------------------------------------+


Applicable output ports
---------------------------------------------------------------------------

.. table:: Decoder applicable output ports

           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | Name                                 | Destination                                   | Purpose                                                 |
           +======================================+===============================================+=========================================================+
           | ``instr_multicycle_o``               | Controller (ID)                               | Multi-cycle indicator                                   |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``illegal_insn_o``                   | Controller (ID)                               | Illegal instruction encountered                         |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``ebrk_insn_o``                      | Controller (ID)                               | Trap instruction encountered                            |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mret_insn_o``                      | Controller (ID)                               | Return from exception instruction encountered (M)       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``uret_insn_o``                      | Controller (ID)                               | Return from exception instruction encountered (S)       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``ecall_insn_o``                     | Controller (ID)                               | Environmental call (sys-call) instruction encountered   |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``pipe_flush_o``                     | Controller (ID)                               | Pipeline flush is required                              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``rega_used_o``                      | Controller (ID) via comparators               | ``rs1`` is used by current instruction                  |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regb_used_o``                      | Controller (ID) via comparators               | ``rs2`` is used by current instruction                  |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regc_used_o``                      | Controller (ID) via comparators               | ``rs3`` is used by current instruction                  |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``bmask_a_mux_o``                    | ID internal MUX                               | Bit manipulation mask A mux, 0 or immediate             |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``bmask_b_mux_o[1:0]``               | ID internal MUX                               | Bit manipulation mask B mux, 0 or immediate             |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_bmask_a_mux_sel_o``            | ID internal MUX                               | Bit manipulation mask A mux, reg or immediate           |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_bmask_b_mux_sel_o``            | ID internal MUX                               | Bit manipulation mask B mux, reg or immediate           |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_en_o``                         | ALU (EX)                                      | ALU enable                                              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_operator_o[ALU_OP_WIDTH-1:0]`` | ALU (EX)                                      | ALU operation selection                                 |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_op_a_mux_sel_o[2:0]``          | ID internal MUX                               | Operand A selection: reg value, PC, immediate or 0      |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_op_b_mux_sel_o[2:0]``          | ID internal MUX                               | Operand B selection: reg value or immediate             |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_op_c_mux_sel_o[1:0]``          | ID internal MUX                               | Operand C selection: reg value or jump target           |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``alu_vec_mode_o[1:0]``              | ALU (EX)                                      | Select ALU vectorial mode: 32/16/8 bits                 |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``scalar_replication_o``             | ID internal MUX                               | Choose normal or scalar replicated version of operand B |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``imm_a_mux_sel_o``                  | ID internal MUX                               | Immediate selection for operand A                       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``imm_b_mux_sel_o[3:0]``             | ID internal MUX                               | Immediate selection for operand B                       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regc_mux_o[1:0]``                  | ID internal MUX                               | Register C selection: S1, RF read C-port or 0           |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_operator_o[2:0]``             | Multiplier (EX)                               | Multiplication operation selection                      |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_int_en_o``                    | ID internal                                   | Perform integer multiplication                          |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_dot_en_o``                    | ID internal                                   | Perform dot multiplication                              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_imm_mux_o``                   | ID internal MUX                               | Multiplication immediate MUX selection: S3 or 0         |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_sel_subword_o``               | Multiplier (EX)                               | Select sub-words for 16x16 bits multiplication          |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_signed_mode_o[1:0]``          | Multiplier (EX)                               | Multiplication in signed mode                           |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``mult_dot_signed_o[1:0]``           | Multiplier (EX)                               | Dot product in signed mode                              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regfile_mem_we_o``                 | Controller (ID) + WB logic (WB)               | Write enable for the RegFile                            |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regfile_alu_we_o``                 | ALU FW logic (EX)                             | Write enable for the 2\ :sup:`nd` RegFile port          |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``regfile_alu_waddr_sel_o``          | ID internal MUX                               | Select register write address for ALU/MUL operations    |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``csr_access_o``                     | Controller (ID) + part of id_ready            | Access CSR                                              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``csr_status_o``                     | Controller (ID)                               | Access status CSR                                       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``csr_op_o[1:0]``                    | CSR (EX)                                      | Operation to perform on CSR                             |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_req_o``                       | Controller (ID) + LSU (WB) + part of ex_valid | Start transaction to data memory                        |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_we_o``                        | LSU (WB)                                      | Data memory write enable                                |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``prepost_useincr_o``                | LSU (WB)                                      | Bypass ALU for address calculation when inactive        |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_type_o[1:0]``                 | LSU (WB)                                      | Data type on data memory: byte, half-word or word       |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_sign_extension_o``            | LSU (WB)                                      | Sign extension on read data from the data memory        |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_reg_offset_o[1:0]``           | LSU (WB)                                      | Offset in bytes inside register for store               |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``data_load_event_o``                | Debug unit (IF) + Controller (ID)             | Data request is in the special event range              |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``hwloop_we_o[2:0]``                 | ID internal MUX-es                            | Write enable for H/W loop registers                     |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``hwloop_target_mux_sel_o``          | ID internal MUX                               | Selects immediate for H/W loop target                   |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``hwloop_start_mux_sel_o``           | ID internal MUX                               | Selects H/W loop start address input                    |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``hwloop_cnt_mux_sel_o``             | ID internal MUX                               | Selects H/W loop counter input                          |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``jump_in_id_o[1:0]``                | Controller (ID)                               | Jump calculated in ALU                                  |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``jump_in_dec_o[1:0]``               | Controller (ID)                               | ``jump_in_id`` without de-assertion                     |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+
           | ``jump_target_mux_sel_o[1:0]``       | ID internal MUX                               | Jump target selection                                   |
           +--------------------------------------+-----------------------------------------------+---------------------------------------------------------+

|

.. figure:: /figures/decoder_block.PNG
      :scale: 80%

      Decoder block ports

|

###########################################################################
Opcodes
###########################################################################

.. table:: Decoder opcode options

          +-----------------------+--------------+-----------+
          | Mnemonic              | BIN value    | HEX value |
          +=======================+==============+===========+
          | ``OPCODE_LOAD``       | 00000-11     | 0x03      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_LOAD_FP``    | 00001-11     | 0x07      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_LOAD_POST``  | 00010-11     | 0x0B      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **00011**-11 | **0x0F**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OPIMM``      | 00100-11     | 0x13      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_AUIPC``      | 00101-11     | 0x17      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **00110**-11 | **0x1B**  |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **00111**-11 | **0x1F**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_STORE``      | 01000-11     | 0x23      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_STORE_FP``   | 01001-11     | 0x27      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_STORE_POST`` | 01010-11     | 0x2B      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **01011**-11 | **0x2F**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP``         | 01100-11     | 0x33      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_LUI``        | 01101-11     | 0x37      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **01110**-11 | **0x3B**  |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **01111**-11 | **0x3F**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP_FMADD``   | 10000-11     | 0x43      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP_FMSUB``   | 10001-11     | 0x47      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP_FNMSUB``  | 10010-11     | 0x4B      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP_FNMADD``  | 10011-11     | 0x4F      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_OP_FP``      | 10100-11     | 0x53      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_VECOP``      | 10101-11     | 0x57      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_PULP_OP``    | 10110-11     | 0x5B      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **10111**-11 | **0x5F**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_BRANCH``     | 11000-11     | 0x63      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_JALR``       | 11001-11     | 0x67      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **11010**-11 | **0x6B**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_JAL``        | 11011-11     | 0x6F      |
          +-----------------------+--------------+-----------+
          | ``OPCODE_SYSTEM``     | 11100-11     | 0x73      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **11101**-11 | **0x77**  |
          +-----------------------+--------------+-----------+
          | ``OPCODE_HWLOOP``     | 11110-11     | 0x7B      |
          +-----------------------+--------------+-----------+
          | **AVAILABLE**         | **11111**-11 | **0x7F**  |
          +-----------------------+--------------+-----------+


###########################################################################
Command groups
###########################################################################

***************************************************************************
Jumps
***************************************************************************

**JAL** = Jump and Link
---------------------------------------------------------------------------

Unconditional jump J-type command:

.. figure:: /figures/JAL.png
   :scale: 80%

   JAL command fields

OPCODE = 0x6F
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* IF address gets ``PC(ID) + offset[20:1]``
* ``PC(ID)+4`` stored into ``RF[rd]`` @ EX stage
* Unconditional jumps use zero register (``x``\ `0`:sub: ``=0``) as dummy destination
* ``offset[0]=0`` ensures jumps in half word resolution for 16 bits instructions

Non-default signals involved
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. table:: Decoder JAL command non-default signals

   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | Signal                         | Mnemonic    | Value | Meaning                                                    |
   +================================+=============+=======+============================================================+
   | ``jump_target_mux_sel_o[1:0]`` | JT_JAL      |   0x1 | Jump target is PC(ID) + offset                             |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``jump_in_dec_o[1:0]``         | BRANCH_JAL  |   0x1 | PC source is PC_JUMP -> IF address is ``jump_target`` (ID) |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``jump_in_id_o[1:0]``          | BRANCH_JAL  |   0x1 | PC source is PC_JUMP -> IF address is ``jump_target`` (ID) |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_op_a_mux_sel_o[2:0]``    | OP_A_CURRPC |   0x1 | ALU A operand is current PC                                |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_op_b_mux_sel_o[2:0]``    | OP_B_IMM    |   0x2 | ALU B operand is immediate                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``       | IMMB_PCINCR |   0x3 | B operand's immediate is 4                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_operator_o[6:0]``        | ALU_ADD     |  0x18 | ALU addition                                               |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``regfile_alu_we``             | \-          |     1 | Write enable for the 2\ :sup:`nd` RegFile port             |
   +--------------------------------+-------------+-------+------------------------------------------------------------+


RTL code block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: systemverilog

   OPCODE_JAL: begin   // Jump and Link
      jump_target_mux_sel_o = JT_JAL;
      jump_in_id            = BRANCH_JAL;
      alu_op_a_mux_sel_o    = OP_A_CURRPC;
      alu_op_b_mux_sel_o    = OP_B_IMM;
      imm_b_mux_sel_o       = IMMB_PCINCR;
      alu_operator_o        = ALU_ADD;
      regfile_alu_we        = 1'b1;
   end


**JALR** = Jump and Link Register
---------------------------------------------------------------------------

Unconditional jump I-type command:

.. figure:: /figures/JALR.png


            JALR command fields

OPCODE = 0x67
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* IF address gets ``RF[rs1] + offset[11:0]``
* ``PC(ID)+4`` stored into ``RF[rd]`` @ EX stage
* Unconditional jumps use zero register (``x``\ `0`:sub: ``=0``) as dummy destination
* ``offset[0]=0`` ensures jumps in half word resolution for 16 bits instructions


Non-default signals involved
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. table:: Decoder JALR command non-default signals

   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | Signal                         | Mnemonic    | Value | Meaning                                                    |
   +================================+=============+=======+============================================================+
   | ``jump_target_mux_sel_o[1:0]`` | JT_JALR     |  0x2  | Jump target is PC(ID) + offset                             |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``jump_in_dec_o[1:0]``         | BRANCH_JALR |  0x2  | PC source is PC_JUMP -> IF address is ``jump_target`` (ID) |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``jump_in_id_o[1:0]``          | BRANCH_JALR |  0x2  | PC source is PC_JUMP -> IF address is ``jump_target`` (ID) |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_op_a_mux_sel_o[2:0]``    | OP_A_CURRPC |  0x1  | ALU A operand is current PC                                |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_op_b_mux_sel_o[2:0]``    | OP_B_IMM    |  0x2  | ALU B operand is immediate                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``       | IMMB_PCINCR |  0x3  | B operand's immediate is 4                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_operator_o[6:0]``        | ALU_ADD     | 0x18  | ALU addition                                               |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``regfile_alu_we``             | \-          |    1  | Write enable for the 2\ :sup:`nd` RegFile port             |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``rega_used_o``                | \-          |    1  | ``rs1`` is used by current instruction                     |
   +--------------------------------+-------------+-------+------------------------------------------------------------+

If ``func3`` is not 0, the instruction marked as illegal:

+------------------------+-------------+-------+------------------------------------------------+
| Signal                 | Mnemonic    | Value | Meaning                                        |
+========================+=============+=======+================================================+
| ``jump_in_dec_o[1:0]`` | BRANCH_NONE | 0x0   | ???                                            |
+------------------------+-------------+-------+------------------------------------------------+
| ``jump_in_id_o[1:0]``  | BRANCH_NONE | 0x0   | ???                                            |
+------------------------+-------------+-------+------------------------------------------------+
| ``regfile_alu_we``     | \-          |   0   | Write enable for the 2\ :sup:`nd` RegFile port |
+------------------------+-------------+-------+------------------------------------------------+
| ``illegal_insn_o``     | \-          |   1   | Illegal instruction                            |
+------------------------+-------------+-------+------------------------------------------------+


RTL code block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: systemverilog

   OPCODE_JALR: begin  // Jump and Link Register
      jump_target_mux_sel_o = JT_JALR;
      jump_in_id            = BRANCH_JALR;
      alu_op_a_mux_sel_o    = OP_A_CURRPC;
      alu_op_b_mux_sel_o    = OP_B_IMM;
      imm_b_mux_sel_o       = IMMB_PCINCR;
      alu_operator_o        = ALU_ADD;
      regfile_alu_we        = 1'b1;
      rega_used_o           = 1'b1;

      if (instr_rdata_i[14:12] != 3'b0) begin
         jump_in_id       = BRANCH_NONE;
         regfile_alu_we   = 1'b0;
         illegal_insn_o   = 1'b1;
      end
   end


**BRANCH** = Conditional branches
---------------------------------------------------------------------------
Conditional jump SB-type command:

.. figure:: /figures/BRANCH.png
   :scale: 80%

   BRANCH command fields

OPCODE = 0x63
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* Condition between 2 registers checked:
   - ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
   - ``RF[rs2]`` read out of the register file's read B-port and used as ALU's B operand
   - ALU @ EX stage compares A vs. B operands and ``branch_taken_ex`` indicates the result
* Jump target address is ``PC(ID)+offset[12:1]``
* Jump target addess propagated to EX stage as ALU C operand & then fed back as IF address (if ``branch_taken_ex=1``)
* ``offset[0]=0`` ensures jumps in half word resolution for 16 bits instructions

  .. note:: 2 additional comparison flavors for BEQ/BNE,
          with register *vs.* sign extended ``src2`` immediate

Non-default signals involved
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. table:: Decoder BRANCH command common non-default signals

   +--------------------------------+-------------+-------+-----------------------------------------+
   | Signal                         | Mnemonic    | Value | Meaning                                 |
   +================================+=============+=======+=========================================+
   | ``jump_target_mux_sel_o[1:0]`` | JT_COND     | 0x2   | Jump target is PC(ID) + offset          |
   +--------------------------------+-------------+-------+-----------------------------------------+
   | ``jump_in_dec_o[1:0]``         | BRANCH_COND | 0x3   | ???                                     |
   +--------------------------------+-------------+-------+-----------------------------------------+
   | ``jump_in_id_o[1:0]``          | BRANCH_COND | 0x3   | ???                                     |
   +--------------------------------+-------------+-------+-----------------------------------------+
   | ``alu_op_c_mux_sel_o[2:0]``    | OP_C_JT     | 0x1   | ALU C operand propagated as jump target |
   +--------------------------------+-------------+-------+-----------------------------------------+
   | ``rega_used_o``                | \-          |   1   | ``rs1`` is used by current instruction  |
   +--------------------------------+-------------+-------+-----------------------------------------+
   | ``regb_used_o``                | \-          |   1   | ``rs2`` is used by current instruction  |
   +--------------------------------+-------------+-------+-----------------------------------------+

.. note:: BEQ/BNE register *vs.* immediate branch flavors (``funct3 = 3'b10*``) require only one register, thus some of the signals should be altered.

   +--------------------------------+-------------+-------+-------------------------------------------------+
   | Signal                         | Mnemonic    | Value | Meaning                                         |
   +================================+=============+=======+=================================================+
   | ``regb_used_o``                | \-          | 0x0   | ``rs2`` isn't used by current instruction       |
   +--------------------------------+-------------+-------+-------------------------------------------------+
   | ``alu_op_b_mux_sel_o[2:0]``    | OP_B_IMM    | 0x2   | ALU B operand is immediate                      |
   +--------------------------------+-------------+-------+-------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``       | IMMB_BI     | 0xB   | B operand's immediate is sign extended ``src2`` |
   +--------------------------------+-------------+-------+-------------------------------------------------+


RTL code block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: systemverilog

   OPCODE_BRANCH: begin // Branch
      jump_target_mux_sel_o = JT_COND;
      jump_in_id            = BRANCH_COND;
      alu_op_c_mux_sel_o    = OP_C_JT;
      rega_used_o           = 1'b1;
      regb_used_o           = 1'b1;

      unique case (instr_rdata_i[14:12])
         3'b000: alu_operator_o = ALU_EQ;
         3'b001: alu_operator_o = ALU_NE;
         3'b100: alu_operator_o = ALU_LTS;
         3'b101: alu_operator_o = ALU_GES;
         3'b110: alu_operator_o = ALU_LTU;
         3'b111: alu_operator_o = ALU_GEU;
         3'b010: begin
            alu_operator_o      = ALU_EQ;
            regb_used_o         = 1'b0;
            alu_op_b_mux_sel_o  = OP_B_IMM;
            imm_b_mux_sel_o     = IMMB_BI;
         end
         3'b011: begin
            alu_operator_o      = ALU_NE;
            regb_used_o         = 1'b0;
            alu_op_b_mux_sel_o  = OP_B_IMM;
            imm_b_mux_sel_o     = IMMB_BI;
         end
      endcase
   end


***************************************************************************
Memory data load
***************************************************************************
The current implementation of the RI5CY's decoder supports 4 flavors of the LOAD command:

* LOAD:      Register-immediate (Standard RISC-V)
* LOAD:      Register-register
* LOAD_POST: Register-immediate with post-increment
* LOAD_POST: Register-register with post-increment

.. note:: There is one more special case, called `data event`, which will be elaborated later.

All the LOAD instruction flavors share the same state of common signals:

.. table:: Decoder memory load common non-default signals

   +-----------------------------+----------+--------+-----------------------------------------------+
   | Signal                      | Mnemonic | Value  | Meaning                                       |
   +=============================+==========+========+===============================================+
   | ``alu_op_b_mux_sel_o[2:0]`` | OP_B_IMM |   0x2  | ALU B operand is immediate                    |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``rega_used_o``             | \-       |     1  | ``rs1`` is used by current instruction        |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``    | IMMB_I   |   0x0  | ALU B operand's immediate is of I-type        |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``alu_operator_o[6:0]``     | ALU_ADD  |  0x18  | ALU performs addition                         |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``data_req``                | \-       |     1  | Start transaction to data memory              |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``regfile_mem_we``          | \-       |     1  | WB write enable for the RegFile               |
   +-----------------------------+----------+--------+-----------------------------------------------+
   | ``instr_multicycle_o``      | \-       |     1  | Multi-cycle indicator                         |
   +-----------------------------+----------+--------+-----------------------------------------------+

**LOAD**
---------------------------------------------------------------------------
The LOAD command might have register *vs.* immediate (**reg-2-imm**) or register *vs.* register (**reg-2-reg**) flavors.

The sub-type is determined with the ``instr[14:12]`` *a.k.a* ``funct3`` field:

.. table:: Load flavors

   +------------------+---------------------------------------+------------------+
   | ``funct3`` value | Flavor                                | Decoding type    |
   +==================+=======================================+==================+
   |              000 | **reg-2-imm** load byte               | I-type           |
   +------------------+---------------------------------------+------------------+
   |              001 | **reg-2-imm** load half word          | I-type           |
   +------------------+---------------------------------------+------------------+
   |              010 | **reg-2-imm** load word               | I-type           |
   +------------------+---------------------------------------+------------------+
   |              011 | Illegal instruction                   | I-type           |
   +------------------+---------------------------------------+------------------+
   |              100 | **reg-2-imm** load unsigned byte      | I-type           |
   +------------------+---------------------------------------+------------------+
   |              101 | **reg-2-imm** load unsigned half word | I-type           |
   +------------------+---------------------------------------+------------------+
   |              110 | Data event load                       | I-type           |
   +------------------+---------------------------------------+------------------+
   |              111 | **reg-2-reg** load                    | R-type           |
   +------------------+---------------------------------------+------------------+


OPCODE = 0x03
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

reg-2-imm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Register *vs.* immediate is the standard RISC-V form of the load command.
I-type command:

.. figure:: /figures/LOAD.png
   :scale: 80%

   RISC-V LOAD command fields


Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ``offset[11:0]`` sign extended and used as ALU's B operand
* A + B result (see **Note**) is used as a memory address
* Read memory data is written back to the ``RF[rd]`` via write A-port

.. note:: The A + B addition not done by ALU, but a dedicated adder H/W in the LSU.

Load data type
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The type of the loaded data is determined with the ``instr[13:12]`` bits:

+------------------+------------------------+-------------------------+
| ``instr[13:12]`` | Load data type         | Data type indicator     |
+==================+========================+=========================+
| ``2'b10``        | Full 32 bits wide word | ``data_type_o = 2'b00`` |
+------------------+------------------------+-------------------------+
| ``2'b01``        | 16 bits wide half-word | ``data_type_o = 2'b01`` |
+------------------+------------------------+-------------------------+
| Other            | 8 bits wide byte       | ``data_type_o = 2'b10`` |
+------------------+------------------------+-------------------------+

.. attention:: **not**\ (``instr[14]``) used for sign extension.

Data event load special case
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The event load interpretation of the LOAD instruction is a non-standard PULP implementation. It occurs when the ``funct3 = 3'b110``. All the decoder's relevant output signals remain as in a regular reg-2-imm case, except additional assertion of the ``data_load_event_o`` signal.

This signal is used by:

* Controller (ID) to progress to ``ELW_EXE`` state
* Debug unit
* Part of the ``core_busy`` logic

reg-2-reg
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Register *vs.* register LOAD is a non-standard PULP implementation, which interpreted as R-type instruction:

.. figure:: /figures/R_type.PNG
   :scale: 80%

   R-type instruction fields

Similar to the regular LOAD instruction:

* ``rd`` refered as destination
* ``rs1`` as a base address

On the other hand:

* ``funct3 = 3'b111``
* ``rs2`` refered as an offset register
* ``funct7`` used to sub-categorize the command

Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ``RF[rs2]`` read out of the register file's read B-port and used as ALU's B operand
* A + B result (see **Note**) is used as a memory address
* Read memory data is written back to the ``RF[rd]`` via write A-port

.. note:: The A + B addition not done by ALU, but a dedicated adder H/W in the LSU.

Few signals changed in order to use the 2\ :sup:`nd` register:

+-----------------------------+------------------+-------+---------------------------------------------+
| Signal                      | Mnemonic         | Value | Meaning                                     |
+=============================+==================+=======+=============================================+
| ``alu_op_b_mux_sel_o[2:0]`` | OP_B_REGB_OR_FWD |  0x0  | ALU B operand taken from the RF read B-port |
+-----------------------------+------------------+-------+---------------------------------------------+
| ``regb_used_o``             | \-               |    1  | ``rs2`` is used by current instruction      |
+-----------------------------+------------------+-------+---------------------------------------------+


Load data type
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The type of the loaded data is determined with the ``instr[31:25]`` bits:

+------------------+-------------------------------+-------------------------+
| ``instr[31:25]`` | Load data type                | Data type indicator     |
+==================+===============================+=========================+
| ``7'b0010000``   | Full 32 bits wide word        | ``data_type_o = 2'b00`` |
+------------------+-------------------------------+-------------------------+
| ``7'b0*01000``   | 16 bits wide half-word        | ``data_type_o = 2'b01`` |
+------------------+-------------------------------+-------------------------+
| ``7'b0*00000``   | 8 bits wide byte              | ``data_type_o = 2'b10`` |
+------------------+-------------------------------+-------------------------+
| Other            | Marked as illegal instruction | Not set                 |
+------------------+-------------------------------+-------------------------+

.. important:: **not**\ (``instr[30]``) used for sign extension.

LOAD flavors summary table
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| **Instruction**                          | **Type** | ``instr[31:25]`` | ``instr[24:20]`` | ``rs1`` | ``funct3`` | ``rd`` | ``opcode`` |
+==========================================+==========+==================+==================+=========+============+========+============+
| Load signed extended reg-2-imm byte      | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        000 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load signed extended reg-2-imm half-word | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        001 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load reg-2-imm word                      | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        010 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Illegal                                  | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        011 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load zero extended reg-2-imm byte        | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        100 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load zero extended reg-2-imm half-word   | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        101 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Data load event                          | I-type   | imm-offset[11:5] | imm-offset[4:0]  | base    |        110 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load signed extended reg-2-reg byte      | R-type   | 0000000          | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load signed extended reg-2-reg half-word | R-type   | 0001000          | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load reg-2-reg word                      | R-type   | 0010000          | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load zero extended reg-2-reg byte        | R-type   | 0100000          | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Load zero extended reg-2-reg half-word   | R-type   | 0101000          | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+
| Illegal                                  | R-type   | Rest             | reg-offset       | base    |        111 | dest   |    0x3     |
+------------------------------------------+----------+------------------+------------------+---------+------------+--------+------------+

**LOAD_POST**
---------------------------------------------------------------------------
The LOAD_POST instruction behaves similarly to **LOAD**, apart the state of following signals:

.. list-table::
   :widths: 10 10 30
   :header-rows: 1

   * - Signal
     - Value
     - Meaning
   * - ``prepost_useincr_o``
     - 0
     - Memory address = ALU's A operand value (not A + B)
   * - ``regfile_alu_waddr_sel_o``
     - 0
     - RF's write B-port address selected directly by ``rs1``. The post-increment H/W drives the RF's write B-port with new
       data to update ``RF[rs1]`` register for next iteration.
   * - ``regfile_alu_we``
     - 1
     - Write enable for RF's write B-port (in parallel to A-port, which gets the readen memory data).

This instruction is intended for DMA loops, which traverse through memory blocks.

RTL code block
---------------------------------------------------------------------------

.. code-block:: systemverilog
   :linenos:
   :emphasize-lines: 5

   OPCODE_LOAD, OPCODE_LOAD_POST: begin
      data_req            = 1'b1;
      regfile_mem_we      = 1'b1;
      rega_used_o         = 1'b1;
      data_type_o         = 2'b00; // SlavaY: redundant - should be removed
      instr_multicycle_o  = 1'b1;

      // Offset from immediate:
      alu_operator_o      = ALU_ADD;
      alu_op_b_mux_sel_o  = OP_B_IMM;
      imm_b_mux_sel_o     = IMMB_I;

      // Post-increment setup:
      if (instr_rdata_i[6:0] == OPCODE_LOAD_POST) begin
         prepost_useincr_o       = 1'b0;
         regfile_alu_waddr_sel_o = 1'b0;
         regfile_alu_we          = 1'b1;
      end

      // Sign/zero extension:
      data_sign_extension_o = ~instr_rdata_i[14];

      // Load size:
      unique case (instr_rdata_i[13:12])
         2'b00:   data_type_o = 2'b10; // LB
         2'b01:   data_type_o = 2'b01; // LH
         2'b10:   data_type_o = 2'b00; // LW
         default: data_type_o = 2'b00; // illegal or reg-reg
      endcase

      // reg-reg load (different encoding):
      if (instr_rdata_i[14:12] == 3'b111) begin
         // Offset from RS2:
         regb_used_o        = 1'b1;
         alu_op_b_mux_sel_o = OP_B_REGB_OR_FWD;

         // Sign/zero extension:
         data_sign_extension_o = ~instr_rdata_i[30];

         // Load size
         unique case (instr_rdata_i[31:25])
            7'b0000_000, 7'b0100_000: data_type_o = 2'b10; // LB, LBU
            7'b0001_000, 7'b0101_000: data_type_o = 2'b01; // LH, LHU
            7'b0010_000:              data_type_o = 2'b00; // LW
            default: begin
               illegal_insn_o = 1'b1;
            end
         endcase
      end

      // Special p.elw (event load):
      if (instr_rdata_i[14:12] == 3'b110)
         data_load_event_o = 1'b1;

      if (instr_rdata_i[14:12] == 3'b011) begin
         illegal_insn_o = 1'b1;
      end
   end

***************************************************************************
Memory data store
***************************************************************************
Similarly to LOAD instruction, the current implementation of the RI5CY's decoder supports 4 flavors of the STORE command:

* STORE:      Register-immediate (Standard RISC-V)
* STORE:      Register-register
* STORE_POST: Register-immediate with post-increment
* STORE_POST: Register-register with post-increment

All the STORE instruction flavors share the same state of common signals:

.. table:: Decoder memory store common non-default signals

   +-----------------------------+------------------+--------+-----------------------------------------------+
   | Signal                      | Mnemonic         | Value  | Meaning                                       |
   +=============================+==================+========+===============================================+
   | ``alu_op_c_mux_sel_o[1:0]`` | OP_C_REGB_OR_FWD |   0x1  | ALU C operand read out of RF's B read port    |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``rega_used_o``             | \-               |     1  | ``rs1`` is used by current instruction        |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``regb_used_o``             | \-               |     1  | ``rs2`` is used by current instruction        |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``alu_operator_o[6:0]``     | ALU_ADD          |  0x18  | ALU performs addition                         |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``data_req``                | \-               |     1  | Start transaction to data memory              |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``data_we_o``               | \-               |     1  | Enable memory data write                      |
   +-----------------------------+------------------+--------+-----------------------------------------------+
   | ``instr_multicycle_o``      | \-               |     1  | Multi-cycle indicator                         |
   +-----------------------------+------------------+--------+-----------------------------------------------+

Both STORE flavors (regular & post) share the same definitions of data size, determined by ``instr[13:12]`` bits:

+------------------+------------------------+-------------------------+
| ``instr[13:12]`` | Load data type         | Data type indicator     |
+==================+========================+=========================+
| ``2'b00``        | 8 bits wide byte       | ``data_type_o = 2'b10`` |
+------------------+------------------------+-------------------------+
| ``2'b01``        | 16 bits wide half-word | ``data_type_o = 2'b01`` |
+------------------+------------------------+-------------------------+
| ``2'b10``        | Full 32 bits wide word | ``data_type_o = 2'b00`` |
+------------------+------------------------+-------------------------+
| ``2'b11``        | Illegal instruction    | Note set                |
+------------------+------------------------+-------------------------+


**STORE**
---------------------------------------------------------------------------
The STORE command might have register *vs.* immediate (**reg-2-imm**) or register *vs.* register (**reg-2-reg**) flavors. which selected by ``instr[14]``:

* reg-2-imm STORE when ``instr[14] = 0``
* reg-2-reg STORE when ``instr[14] = 1``

Both STORE flavors decoded as S-type instructions:

.. figure:: /figures/STORE.png
   :scale: 80%

   STORE command fields


OPCODE = 0x23
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

reg-2-imm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Register *vs.* immediate is the standard RISC-V form of the STORE command. It requires the ALU's B operand to be an emmidiate, therefore these 2 signals updated accordingly:

+-----------------------------+----------+-------+----------------------------------------+
| Signal                      | Mnemonic | Value | Meaning                                |
+=============================+==========+=======+========================================+
| ``alu_op_b_mux_sel_o[2:0]`` | OP_B_IMM |   0x2 | ALU B operand is immediate             |
+-----------------------------+----------+-------+----------------------------------------+
| ``imm_b_mux_sel_o[3:0]``    | IMMB_S   |   0x1 | ALU B operand's immediate is of S-type |
+-----------------------------+----------+-------+----------------------------------------+


Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ``offset[11:0]`` sign extended and used as ALU's B operand
* A + B result (see **Note**) is used as a memory write address
* ``RF[rs2]`` read out of the register file's read B-port and used as ALU's C operand
* ALU's C operand  used as a memory write data

.. note:: The A + B addition not done by ALU, but a dedicated adder H/W in the LSU.

reg-2-reg
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Register *vs.* register is a non-standard PULP implementation, where ``instr[11:7]`` is used as ``rs3``. It requires the ALU's B operand to be read out of RF, therefore these 3 signals updated accordingly:

+-----------------------------+------------------+-------+------------------------------------------------+
| Signal                      | Mnemonic         | Value | Meaning                                        |
+=============================+==================+=======+================================================+
| ``regc_used_o``             | \-               | 1     | ``rs3`` is used by current instruction         |
+-----------------------------+------------------+-------+------------------------------------------------+
| ``alu_op_b_mux_sel_o[2:0]`` | OP_B_REGC_OR_FWD | 0x1   | ALU's B operand read out of RF's C read port   |
+-----------------------------+------------------+-------+------------------------------------------------+
| ``regc_mux_o[1:0]``         | REGC_RD          | 0x1   | RF's read C-port's address selected by ``rs3`` |
+-----------------------------+------------------+-------+------------------------------------------------+


Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ``RF[rs3]`` read out of the register file's read C-port and used as ALU's B operand
* A + B result (see **Note**) is used as a memory write address
* ``RF[rs2]`` read out of the register file's read B-port and used as ALU's C operand
* ALU's C operand  used as a memory write data

.. note:: The A + B addition not done by ALU, but a dedicated adder H/W in the LSU.

**STORE_POST**
---------------------------------------------------------------------------
The STORE_POST instruction behaves similarly to **STORE**, apart the state of following signals:

+-----------------------------+-------+--------------------------------------------------------------+
| Signal                      | Value | Meaning                                                      |
+=============================+=======+==============================================================+
| ``prepost_useincr_o``       | 0     | Memory address = ALU's A operand value (not A + B)           |
+-----------------------------+-------+--------------------------------------------------------------+
| ``regfile_alu_waddr_sel_o`` | 0     | RF's write B-port address selected directly by ``rs1``.      |
|                             |       | The post-increment H/W drives the RF's write B-port with new |
|                             |       | data to update ``RF[rs1]`` register for next iteration.      |
+-----------------------------+-------+--------------------------------------------------------------+
| ``regfile_alu_we``          |     1 | Write enable for RF's write B-port (in parallel to A-port,   |
|                             |       | which gets the readen memory data).                          |
+-----------------------------+-------+--------------------------------------------------------------+

This instruction is intended for DMA loops, which traverse through memory blocks.

RTL code block
---------------------------------------------------------------------------

.. code-block:: systemverilog

   CODE_STORE, OPCODE_STORE_POST: begin
      data_req           = 1'b1;
      data_we_o          = 1'b1;
      rega_used_o        = 1'b1;
      regb_used_o        = 1'b1;
      alu_operator_o     = ALU_ADD;
      instr_multicycle_o = 1'b1;

      // Pass write data through ALU operand C:
      alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;

      // Post-increment setup:
      if (instr_rdata_i[6:0] == OPCODE_STORE_POST) begin
         prepost_useincr_o       = 1'b0;
         regfile_alu_waddr_sel_o = 1'b0;
         regfile_alu_we          = 1'b1;
      end

      if (instr_rdata_i[14] == 1'b0) begin
         // Offset from immediate:
         imm_b_mux_sel_o     = IMMB_S;
         alu_op_b_mux_sel_o  = OP_B_IMM;
      end else begin
         // Offset from register:
         regc_used_o        = 1'b1;
         alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
         regc_mux_o         = REGC_RD;
      end

      // Store size:
      unique case (instr_rdata_i[13:12])
         2'b00: data_type_o = 2'b10; // SB
         2'b01: data_type_o = 2'b01; // SH
         2'b10: data_type_o = 2'b00; // SW
         default: begin
            data_req       = 1'b0;
            data_we_o      = 1'b0;
            illegal_insn_o = 1'b1;
         end
      endcase
   end

***************************************************************************
ALU operations
***************************************************************************

Most of the ALU operations could be categorized as integer reg-2-imm or reg-2-reg, apart from LUI & AUIPC special commands. These 2 instructions used long offsets calculations.

Upper Immediate commands
---------------------------------------------------------------------------

Both upper immediate instructions share the U-type & fields:

.. figure:: /figures/Upper_immediate.PNG
   :scale: 80%

   Upper immediate instructions fields

**LUI** - Load Upper Immediate
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
LUI is used to indirectly (via register) built 32-bit long constants. First, comes the LUI instruction with 20-bits immediate and then command with a 12-bits immediate.

OPCODE = 0x37
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ALU's A operand gets 0 immediate
* ALU's B operand gets ``{imm[31:12],12'h000}`` immediate
* The ALU's A+B result stored into ``RF[rd]`` @ EX stage

Non-default signals involved
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. table:: Decoder LUI command non-default signals

   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | Signal                         | Mnemonic    | Value | Meaning                                                    |
   +================================+=============+=======+============================================================+
   | ``alu_op_a_mux_sel_o[2:0]``    | OP_A_IMM    |   0x2 | ALU A operand is immediate                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_op_b_mux_sel_o[2:0]``    | OP_B_IMM    |   0x2 | ALU B operand is immediate                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``imm_a_mux_sel_o``            | IMMA_ZERO   |     1 | A operand's is 0 immediate                                 |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``       | IMMB_U      |   0x2 | B operand's is U-type immediate                            |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``alu_operator_o[6:0]``        | ALU_ADD     |  0x18 | ALU addition                                               |
   +--------------------------------+-------------+-------+------------------------------------------------------------+
   | ``regfile_alu_we``             | \-          |     1 | Write enable for the 2\ :sup:`nd` (B) RegFile port         |
   +--------------------------------+-------------+-------+------------------------------------------------------------+

**AUIPC** - Add Upper Immediate to PC
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AUIPC is used to built PC-relative addresses, by adding upper 20-bits of the U-immediate to the PC.

OPCODE = 0x17
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Description
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

* ALU's A operand gets the current PC
* ALU's B operand gets ``{instr[31:12],12'h000}`` immediate
* The ALU's A+B result stored into ``RF[rd]`` @ EX stage

Non-default signals involved
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. table:: Decoder AUIPC command non-default signals

   +-----------------------------+-------------+-------+------------------------------------------------------+
   | Signal                      | Mnemonic    | Value | Meaning                                              |
   +=============================+=============+=======+======================================================+
   | ``alu_op_a_mux_sel_o[2:0]`` | OP_A_CURRPC |   0x1 | ALU A operand is current PC                          |
   +-----------------------------+-------------+-------+------------------------------------------------------+
   | ``alu_op_b_mux_sel_o[2:0]`` | OP_B_IMM    |   0x2 | ALU B operand is immediate                           |
   +-----------------------------+-------------+-------+------------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``    | IMMB_U      |   0x2 | B operand's is U-type immediate                      |
   +-----------------------------+-------------+-------+------------------------------------------------------+
   | ``alu_operator_o[6:0]``     | ALU_ADD     |  0x18 | ALU addition                                         |
   +-----------------------------+-------------+-------+------------------------------------------------------+
   | ``regfile_alu_we``          | \-          |     1 | Write enable for the 2\ :sup:`nd` (B) RegFile port   |
   +-----------------------------+-------------+-------+------------------------------------------------------+

**ALU_**\ ``*`` integer reg-2-imm instructions
---------------------------------------------------------------------------

All ALU's reg-2-imm instructions share the I-type & fields:

+--+---+--+--+---+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
|31|...|25|24|...|20|19|  ...  |15|14| ...  |12|11|...|7|6|  ...   |0|
+--+---+--+--+---+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
| ``imm[31:25]``    |   ``rs1``   | ``funct3`` | ``rd`` | ``opcode`` |
+---------+---------+-------------+------------+--------+------------+
|  ctrl   | immed   |     src     |  command   |  dest  |    0x13    |
+---------+---------+-------------+------------+--------+------------+

.. note:: Some of the reg-2-imm shift commands use the ``ctrl`` field for conditional assignments.

OPCODE = 0x13
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* ALU's A operand read out of RF's A read port
* ALU's B operand gets ``instr[31:20]`` immediate
* The ALU's result (depends on ALU sub-command) stored into ``RF[rd]`` @ EX stage

Non-default signals involved
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. table:: Decoder ``ALU_*`` commands non-default signals

   +-----------------------------+------------+-------+------------------------------------------------------+
   | Signal                      | Mnemonic   | Value | Meaning                                              |
   +=============================+============+=======+======================================================+
   | ``alu_op_b_mux_sel_o[2:0]`` | OP_B_IMM   |   0x2 | ALU B operand is immediate                           |
   +-----------------------------+------------+-------+------------------------------------------------------+
   | ``imm_b_mux_sel_o[3:0]``    | IMMB_I     |   0x0 | B operand's is I-type immediate                      |
   +-----------------------------+------------+-------+------------------------------------------------------+
   | ``regfile_alu_we``          | \-         |     1 | Write enable for the 2\ :sup:`nd` (B) RegFile port   |
   +-----------------------------+------------+-------+------------------------------------------------------+
   | ``rega_used_o``             | \-         |     1 | ``rs1`` is used by current instruction               |
   +-----------------------------+------------+-------+------------------------------------------------------+

Summary table
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. list-table:: ALU reg-2-imm commands
   :widths: 20 10 10 50
   :header-rows: 1

   * - ``instr[31:25]``
     - ``instr[24:20]``
     - ``funct3``
     - ALU command
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x0
     - ALU_ADD = Add immediate
   * - ``imm[11:5]=0x00``
     - ``imm[4:0]``
     - 0x1
     - ALU_SLL = Shift left logical by immediate
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x2
     - ALU_SLTS = Set to 1 if < signed immediate
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x3
     - ALU_SLTU = Set to 1 if < unsigned immediate
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x4
     - ALU_XOR = Xor with immediate
   * - ``imm[11:5]=0x00``
     - ``imm[4:0]``
     - 0x5
     - ALU_SRL = Shift right logically by immediate
   * - ``imm[11:5]=0x20``
     - ``imm[4:0]``
     - 0x5
     - ALU_SRA = Shift right arithmetically by immediate
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x6
     - ALU_OR = Or with immediate
   * - ``imm[11:5]``
     - ``imm[4:0]``
     - 0x7
     - ALU_AND = And with immediate
   * - Rest
     - Rest
     - Rest
     - Illegal instruction

RTL code block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: systemverilog

   OPCODE_OPIMM: begin // Register-Immediate ALU Operations
      alu_op_b_mux_sel_o  = OP_B_IMM;
      imm_b_mux_sel_o     = IMMB_I;
      regfile_alu_we      = 1'b1;
      rega_used_o         = 1'b1;

      unique case (instr_rdata_i[14:12])
        3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
        3'b010: alu_operator_o = ALU_SLTS; // Set to one if Lower Than Immediate
        3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
        3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
        3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
        3'b111: alu_operator_o = ALU_AND;  // And with Immediate

        3'b001: begin
           alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate
           if (instr_rdata_i[31:25] != 7'b0)
             illegal_insn_o = 1'b1;
        end

        3'b101: begin
           if (instr_rdata_i[31:25] == 7'b0)
             alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate
           else if (instr_rdata_i[31:25] == 7'b010_0000)
             alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate
           else
             illegal_insn_o = 1'b1;
        end

      endcase
   end


Arithmetic/Logic integer reg-2-reg instructions
---------------------------------------------------------------------------

All integer reg-2-reg arithmetic/logic instructions are R-type and share ``opcode`` & fields:

+--+-----+--+--+---+--+--+---+--+--+-----+--+--+---+-+-+------+-+
|31| ... |25|24|...|20|19|...|15|14| ... |12|11|...|7|6| ...  |0|
+--+-----+--+--+---+--+--+---+--+--+-----+--+--+---+-+-+------+-+
| ``funct7``| ``rs2`` | ``rs1`` | ``funct3``| ``rd`` |``opcode``|
+-----------+---------+---------+-----------+--------+----------+
| cmd_sel2  | src2    | src1    | cmd_sel1  | dest   | 0x33     |
+-----------+---------+---------+-----------+--------+----------+

.. note:: (1) ``funct7`` & ``funct3`` fields select a particular reg-2-reg sub-command.
   (2) Some of the instructions use ``funct7[4:0]`` as ``src3``.

.. attention:: Some of the instructions are not really reg-2-reg, but grouped under this OPCODE & share the fields.

Most of these reg-2-reg commands are ordinary, word-scope commands, but several instructions could be categorized as bit-manipulating. The bit manipulating instructions take place when ``instr[31]=1``.

Each integer reg-2-reg arithmetic/logic instruction use RF's read A-port & writes back the RF's write B-port, namely:

* ``rega_used_o    = 1``
* ``regfile_alu_we = 1``

OPCODE = 0x33
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bit-scope
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bit-scope ALU instructions manipulate slices of word data.

The following tables summarizes all the bit-scope commands options:

.. list-table:: Bit-scope arithmetic/logic instructions
   :widths: 10 10 10 50
   :header-rows: 1

   * - ``instr[30]``
     - ``funct3``
     - Assembly mnemonic
     - Short description
   * - 0
     - 0x0
     - ``p.bextractr``
     - reg-2-reg signed bits slice extraction
   * - 1
     - 0x0
     - ``p.bextract``
     - reg-2-imm signed bits slice extraction
   * - 0
     - 0x1
     - ``p.bextractur``
     - reg-2-reg unsigned bits slice extraction
   * - 1
     - 0x1
     - ``p.bextractu``
     - reg-2-imm unsigned bits slice extraction
   * - 0
     - 0x2
     - ``p.insertr``
     - reg-2-reg bits slice insertion
   * - 1
     - 0x2
     - ``p.insert``
     - reg-2-imm bits slice insertion
   * - 0
     - 0x3
     - ``p.bclrr``
     - reg-2-reg bits slice clear
   * - 1
     - 0x3
     - ``p.bclr``
     - reg-2-imm bits slice clear
   * - 0
     - 0x4
     - ``p.bsetr``
     - reg-2-reg bits slice set
   * - 1
     - 0x4
     - ``p.bset``
     - reg-2-imm bits slice set


**p.bextract** - Signed bits slice extraction (via immediate)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ALU's A operand mask selected as ``S3 = src3 = instr[29:25] = funct7[4:0]``
* ALU's B operand is selected as S2-immediate (``S2 = src2 = {27'0,instr[24:20]}``)
* ALU's B operand mask is selected as ``00000``
* ALU's result ``Sext(OP_A[31:src3])`` written back to ``RF[rd]``

.. seealso:: :ref:`Bit extraction RTL potential issue  <my_attention_box_0>`

Non-default signals involved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. list-table:: State of non-default signals for ``p.bextract`` command
   :widths: 10 10 10 30
   :header-rows: 1

   * - Signal
     - Mnemonic
     - Value
     - Meaning
   * - ``alu_operator_o[6:0]``
     - ALU_BEXT
     - 0x28
     - ALU operation is bit extraction
   * - ``alu_op_b_mux_sel_0[2:0]``
     - OP_B_IMM
     - 0x2
     - ALU's B operand is an immediate
   * - ``imm_b_mux_sel_o[3:0]``
     - IMMB_S2
     - 0x4
     - ALU B operand's immediate is ``S3 = {27'0,src3[4:0]}``
   * - ``bmask_b_mux_o[1:0]``
     - BMASK_B_ZERO
     - 0x2
     - ALU operand B's mask is 5'00000
   * - ``bmask_a_mux_o``
     - BMASK_A_S3
     - 1
     - ALU operand A's mask is ``src3[4:0]`` immediate


**p.bextractr** - Signed bits slice extraction (via register)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* ``RF[rs1]`` read out of the register file's read A-port and used as ALU's A operand
* ALU's A operand mask selected as ``S3 = src3 = instr[29:25] = funct7[4:0]``
* ALU's B operand is selected as ``RF[rs2][9:5]`` slice
* ALU's B operand mask is selected as ``00000``
* ALU's result ``Sext(OP_A[31:src3])`` written back to ``RF[rd]``

.. seealso:: :ref:`Bit extraction RTL potential issue  <my_attention_box_0>`

Non-default signals involved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. list-table:: State of non-default signals for ``p.bextractr`` command
   :widths: 10 10 10 30
   :header-rows: 1

   * - Signal
     - Mnemonic
     - Value
     - Meaning
   * - ``alu_operator_o[6:0]``
     - ALU_BEXT
     - 0x28
     - ALU operation is bit extraction
   * - ``alu_op_b_mux_sel_0[2:0]``
     - OP_B_BMASK
     - 0x4
     - ALU's B operand comes from ``RF[rs2]`` read B-port
   * - ``imm_b_mux_sel_o[3:0]``
     - IMMB_S2
     - 0x4
     - \-
   * - ``bmask_b_mux_o[1:0]``
     - BMASK_B_ZERO
     - 0x2
     - ALU operand B's mask is 5'00000
   * - ``regb_used_o``
     - \-
     - 1
     - RF's read B-port is required
   * - ``alu_bmask_a_mux_sel_o``
     - BMASK_A_REG
     - 1
     - ALU's B operand's bit mask comes from ``RF[rs2]`` read B-port bits ``[9:5]``
   * - ``bmask_a_mux_o``
     - BMASK_A_S3
     - 1
     - \-

**p.bextractu** - Unsigned bits slice extraction (via immediate)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


**p.bextractur** - Unsigned bits slice extraction (via register)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


**p.bclr** - Bits slice clear (via immediate)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


**p.bclrr** - Bits slice clear (via register)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


**p.bset** - Bits slice set (via immediate)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


**p.bsetr** - Bits slice set (via register)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. todo::
   To be described ...


RTL common block of ALU_* reg-2-reg bit-scope instructions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: systemverilog
   :linenos:
   :emphasize-lines: 16, 28

   OPCODE_OP: begin  // Register-Register ALU operation
      regfile_alu_we = 1'b1;
      rega_used_o    = 1'b1;

      if (instr_rdata_i[31]) begin
         // Bit-manipulation instructions
         bmask_a_mux_o       = BMASK_A_S3;
         bmask_b_mux_o       = BMASK_B_S2;
         alu_op_b_mux_sel_o  = OP_B_IMM;

         unique case (instr_rdata_i[14:12])

           3'b000: begin
              alu_operator_o  = ALU_BEXT;
              imm_b_mux_sel_o = IMMB_S2;
              bmask_b_mux_o   = BMASK_B_ZERO;
              if (~instr_rdata_i[30]) begin
                 // Register variant
                 alu_op_b_mux_sel_o     = OP_B_BMASK;
                 alu_bmask_a_mux_sel_o  = BMASK_A_REG;
                 regb_used_o            = 1'b1;
              end
           end

           3'b001: begin
                alu_operator_o  = ALU_BEXTU;
                imm_b_mux_sel_o = IMMB_S2;
                bmask_b_mux_o   = BMASK_B_ZERO;
                if (~instr_rdata_i[30]) begin
                   // Register variant
                   alu_op_b_mux_sel_o     = OP_B_BMASK;
                   alu_bmask_a_mux_sel_o  = BMASK_A_REG;
                   regb_used_o            = 1'b1;
                end
           end

           3'b010: begin
              alu_operator_o      = ALU_BINS;
              imm_b_mux_sel_o     = IMMB_S2;
              regc_used_o         = 1'b1;
              regc_mux_o          = REGC_RD;
              if (~instr_rdata_i[30]) begin
                 // Register variant
                 alu_op_b_mux_sel_o     = OP_B_BMASK;
                 alu_bmask_a_mux_sel_o  = BMASK_A_REG;
                 alu_bmask_b_mux_sel_o  = BMASK_B_REG;
                 regb_used_o            = 1'b1;
              end
           end

           3'b011: begin
              alu_operator_o = ALU_BCLR;
              if (~instr_rdata_i[30]) begin
                 // Register variant
                 regb_used_o            = 1'b1;
                 alu_bmask_a_mux_sel_o  = BMASK_A_REG;
                 alu_bmask_b_mux_sel_o  = BMASK_B_REG;
              end
           end

           3'b100: begin
              alu_operator_o = ALU_BSET;
              if (~instr_rdata_i[30]) begin
                 // Register variant
                 regb_used_o            = 1'b1;
                 alu_bmask_a_mux_sel_o  = BMASK_A_REG;
                 alu_bmask_b_mux_sel_o  = BMASK_B_REG;
              end
           end

           default: illegal_insn_o = 1'b1;
         endcase
      end
      // else { Non-bit manipulalting instrucitons }
   // endcase

.. _my_attention_box_0:
.. attention:: ALU_BEXT functionality issue

  | \(1) I suspect that the **ALU_BEXT**\ ``*`` commands don't operate as expected. The B-mask is a constant 0, thus one of the range limits is always 0. In my opinion the ``bmask_b_mux`` should remain ``BMASK_B_S2`` in order to use ``src2`` as on of the range limits. Thus lines 16 & 28 should be removed.
  | \(2) Maybe more - need to check

Word-scope
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following tables summarizes all the integer reg-2-reg arithmetic/logic word-scope commands options:

.. list-table:: integer reg-2-reg arithmetic/logic word-scope instructions
   :widths: 10 10 10 10 50
   :header-rows: 1

   * - ``funct7``
     - ``funct3``
     - Assembly mnemonic
     - Executing module
     - Short description
   * - 0x00
     - 0x0
     - ``add rd, rs1, rs2``
     - ALU
     - Addition
   * - 0x20
     - 0x0
     - ``sub rd, rs1, rs2``
     - ALU
     - Subtraction
   * - 0x00
     - 0x2
     - ``slts rd, rs1, rs2``
     - ALU
     - Set Lower Than Signed
   * - 0x00
     - 0x3
     - ``sltu rd, rs1, rs2``
     - ALU
     - Set Lower Than Unsigned
   * - 0x00
     - 0x4
     - ``xor rd, rs1, rs2``
     - ALU
     - Logic xor
   * - 0x00
     - 0x6
     - ``or rd, rs1, rs2``
     - ALU
     - Logic or
   * - 0x00
     - 0x7
     - ``and rd, rs1, rs2``
     - ALU
     - Logic and
   * - 0x00
     - 0x1
     - ``sll rd, rs1, rs2``
     - ALU
     - Shift Left Logically
   * - 0x00
     - 0x5
     - ``srl rd, rs1, rs2``
     - ALU
     - Shift Right Logically
   * - 0x20
     - 0x5
     - ``sra rd, rs1, rs2``
     - ALU
     - Shift Right Arithmetically
   * - 0x01
     - 0x0
     - ``mul rd, rs1, rs2``
     - Multiplier
     - Signed 16-bits x signed 16-bits multiply, with LSB16 as result
   * - 0x01
     - 0x1
     - ``mulh rd, rs1, rs2``
     - Multiplier
     - Signed 16-bits x signed 16-bits multiply, with MSB16 as result
   * - 0x01
     - 0x2
     - ``mulhsu rd, rs1, rs2``
     - Multiplier
     - Signed 16-bits x unsigned 16-bits multiply, with MSB16 as result
   * - 0x01
     - 0x3
     - ``mulhu rd, rs1, rs2``
     - Multiplier
     - Unsigned 16-bits x unsigned 16-bits multiply, with MSB16 as result
   * - 0x01
     - 0x4
     - ``div rd, rs1, rs2``
     - Divider
     - Signed 32-bits division
   * - 0x01
     - 0x5
     - ``divu rd, rs1, rs2``
     - Divider
     - Unsigned 32-bits division
   * - 0x01
     - 0x6
     - ``rem rd, rs1, rs2``
     - Divider
     - Signed 32-bits remainder
   * - 0x01
     - 0x7
     - ``remu rd, rs1, rs2``
     - Divider
     - Unsigned 32-bits remainder
   * - 0x21
     - 0x0
     - ``p.mac rd, rs1, rs2``
     - Multiplier
     - Signed 32-bits multiply & accumulate
   * - 0x21
     - 0x1
     - ``p.msu rd, rs1, rs2``
     - Multiplier
     - Signed 32-bits multiply & subtract
   * - 0x02
     - 0x2
     - ``p.slet rd, rs1, rs2``
     - ALU
     - Set Lower Equal Than (signed)
   * - 0x02
     - 0x3
     - ``p.sletu rd, rs1, rs2``
     - ALU
     - Set Lower Equal Than (unsigned)
   * - 0x02
     - 0x4
     - ``p.min rd, rs, rs2``
     - ALU
     - Minimum (signed)
   * - 0x02
     - 0x5
     - ``p.minu rd, rs, rs2``
     - ALU
     - Minimum (unsigned)
   * - 0x02
     - 0x6
     - ``p.max rd, rs, rs2``
     - ALU
     - Minimum (signed)
   * - 0x02
     - 0x7
     - ``p.maxu rd, rs, rs2``
     - ALU
     - Minimum (unsigned)
   * - 0x04
     - 0x5
     - ``p.ror rd, rs1, rs2``
     - ALU
     - Rotate Right
   * - 0x08
     - 0x0
     - ``p.ff1 rd, rs1``
     - ALU
     - Find First 1
   * - 0x08
     - 0x1
     - ``p.fl1 rd, rs1``
     - ALU
     - Find Last 1
   * - 0x08
     - 0x2
     - ``p.clb rd, rs1``
     - ALU
     - Count Leading Bits
   * - 0x08
     - 0x3
     - ``p.cnt rd, rs1``
     - ALU
     - Count Set Bits
   * - 0x08
     - 0x4
     - ``p.exths rd, rs1``
     - ALU
     - Sign-extend Half-word
   * - 0x08
     - 0x5
     - ``p.exthz rd, rs1``
     - ALU
     - Zero-extend Half-word
   * - 0x08
     - 0x6
     - ``p.extbs rd, rs1``
     - ALU
     - Sign-extend Byte
   * - 0x08
     - 0x7
     - ``p.extbz rd, rs1``
     - ALU
     - Zero-extend Byte
   * - 0x02
     - 0x0
     - ``p.abs rd, rs1``
     - ALU
     - Absolute value
   * - 0x0A
     - 0x1
     - ``p.clip rd, rs1, ls2``
     - ALU
     - Clip signed value to 2\ :sup:`(n-1)`
   * - 0x0A
     - 0x2
     - ``p.clipu rd, rs1, ls2``
     - ALU
     - Clip unsigned value to 2\ :sup:`(n-1)`
   * - 0x0A
     - 0x5
     - ``p.clipr rd, rs1, rs2``
     - ALU
     - Clip signed value to n
   * - 0x0A
     - 0x6
     - ``p.clipur rd, rs1, rs2``
     - ALU
     - Clip unsigned value to n

.. todo::
   All these instructions to be elaborated ...

**PULP_OP** = 3-source ALU instructions
---------------------------------------------------------------------------

.. todo::
   To be described ...

There are several ADD/SUB/MUL/MAC commands, which involve 3 operands. This instruction is of R-type, like other ALU instructions.

+--+-----+--+--+---+--+--+---+--+--+-----+--+--+---+-+-+------+-+
|31| ... |25|24|...|20|19|...|15|14| ... |12|11|...|7|6| ...  |0|
+--+-----+--+--+---+--+--+---+--+--+-----+--+--+---+-+-+------+-+
| ``funct7``| ``rs2`` | ``rs1`` | ``funct3``| ``rd`` |``opcode``|
+----+------+---------+---------+-----------+--------+----------+
| f2 | ls3  | src2    | src1    | cmd_sel1  | dest   | 0x5B     |
+----+------+---------+---------+-----------+--------+----------+

All ALU 3 source commands are summarized in the following 2 tables:

* 3 source MUL/MAC commands summary
* 3 source ALU add/sub commands summary

.. note::
   3-source commands categorized by ``cmd_sel1[2:0]`` & ``f2[1:0]``:

   * ``cmd_sel1[1:0]`` selects the operation: MUL/MAC/ADD/SUB
   * ``cmd_sel1[2]`` selects if rounding of the result occurs
   * ``f2[0]`` selects:

     * For MUL/MAC ALU's A & B operands sub-words: low/high
     * For ADD/SUB immediate/register variant

   * ``f2[1]`` selects if operands & result are signed/unsigned

|

.. list-table:: 3 source multiply commands summary
   :widths: 5 5 5 5 5 5 15 55
   :header-rows: 1

   * - ``f2[1:0]``
     - ``ls3[4:0]``
     - ``rs2``
     - ``rs1``
     - ``funct3``
     - ``rd``
     - Assembly mnemonic
     - Description
   * - 00
     - 00000
     - src2
     - src1
     - 000
     - dest
     - ``p.mulu rd, rs1, rs2``
     - Unsigned multiply with low sub-words of A & B operands selected
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 000
     - dest
     - ``p.muluN rd, rs1, rs2, ls3``
     - Unsigned multiply with low sub-words of A & B operands selected & immediate shift
   * - 01
     - 00000
     - src2
     - src1
     - 000
     - dest
     - ``p.mulhhu rd, rs1, rs2``
     - Unsigned multiply with high sub-words of A & B operands selected
   * - 01
     - imm[4:0]
     - src2
     - src1
     - 000
     - dest
     - ``p.mulhhuN rd, rs1, rs2, ls3``
     - Unsigned multiply with high sub-words of A & B operands selected & immediate shift
   * - 10
     - 00000
     - src2
     - src1
     - 000
     - dest
     - ``p.muls rd, rs1, rs2``
     - Signed multiply with low sub-words of A & B operands selected
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 000
     - dest
     - ``p.mulsN rd, rs1, rs2, ls3``
     - Signed multiply with low sub-words of A & B operands selected & immediate shift
   * - 11
     - 00000
     - src2
     - src1
     - 000
     - dest
     - ``p.mulhhs rd, rs1, rs2``
     - Signed multiply with high sub-words of A & B operands selected
   * - 11
     - imm[4:0]
     - src2
     - src1
     - 000
     - dest
     - ``p.mulhhsN rd, rs1, rs2, ls3``
     - Signed multiply with high sub-words of A & B operands selected & immediate shift
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 100
     - dest
     - ``p.muluRN rd, rs1, rs2, ls3``
     - Unsigned multiply & round with low sub-words of A & B operands selected & immediate shift
   * - 01
     - imm[4:0]
     - src2
     - src1
     - 100
     - dest
     - ``p.mulhhuRN rd, rs1, rs2, ls3``
     - Unsigned multiply & round with high sub-words of A & B operands selected & immediate shift
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 100
     - dest
     - ``p.mulsRN rd, rs1, rs2, ls3``
     - Signed multiply & round with low sub-words of A & B operands selected & immediate shift
   * - 11
     - imm[4:0]
     - src2
     - src1
     - 100
     - dest
     - ``p.mulhhsRN rd, rs1, rs2, ls3``
     - Signed multiply & round with high sub-words of A & B operands selected & immediate shift
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 001
     - dest
     - ``p.macuN rd, rs1, rs2, ls3``
     - Unsigned MAC with low sub-words of A & B operands selected & immediate shift
   * - 01
     - imm[4:0]
     - src2
     - src1
     - 001
     - dest
     - ``p.machhuN rd, rs1, rs2, ls3``
     - Unsigned MAC with high sub-words of A & B operands selected & immediate shift
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 001
     - dest
     - ``p.macsN rd, rs1, rs2, ls3``
     - Signed MAC with low sub-words of A & B operands selected & immediate shift
   * - 11
     - imm[4:0]
     - src2
     - src1
     - 001
     - dest
     - ``p.machhsN rd, rs1, rs2, ls3``
     - Signed MAC with high sub-words of A & B operands selected & immediate shift

.. todo::
   All of these MUL/MAC commands to be elaborated ...

.. list-table:: 3 source ALU add/sub commands summary
   :widths: 5 5 5 5 5 5 15 55
   :header-rows: 1

   * - ``f2[1:0]``
     - ``ls3[4:0]``
     - ``rs2``
     - ``rs1``
     - ``funct3``
     - ``rd``
     - Assembly mnemonic
     - Description
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 010
     - dest
     - ``p.addN rd, rs1, rs2, ls3``
     - Unsigned add & shift via ``ls3`` immediate
   * - 01
     - 00000
     - src2
     - src1
     - 010
     - dest
     - ``p.addNr rd, rs1, rs2``
     - Unsigned add & shift via register
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 010
     - dest
     - ``p.adduN rd, rs1, rs2, ls3``
     - Signed add & shift via ``ls3`` immediate
   * - 11
     - 00000
     - src2
     - src1
     - 010
     - dest
     - ``p.adduNr rd, rs1, rs2``
     - Signed add & shift via  register
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 110
     - dest
     - ``p.addRN rd, rs1, rs2, ls3``
     - Unsigned add & round & shift via ``ls3`` immediate
   * - 01
     - 00000
     - src2
     - src1
     - 110
     - dest
     - ``p.addRNr rd, rs1, rs2``
     - Unsigned add & round & shift via register
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 110
     - dest
     - ``p.adduNr rd, rs1, rs2, ls3``
     - Signed add & round & shift via ``ls3`` immediate
   * - 11
     - 00000
     - src2
     - src1
     - 110
     - dest
     - ``p.adduRNr rd, rs1, rs2``
     - Signed add & round & shift via register
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 011
     - dest
     - ``p.subN rd, rs1, rs2, ls3``
     - Unsigned subtract & shift via ``ls3`` immediate
   * - 01
     - 00000
     - src2
     - src1
     - 011
     - dest
     - ``p.subNr rd, rs1, rs2``
     - Unsigned subtract & shift via register
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 011
     - dest
     - ``p.subuN rd, rs1, rs2, ls3``
     - Signed subtract & shift via ``ls3`` immediate
   * - 11
     - 00000
     - src2
     - src1
     - 011
     - dest
     - ``p.subuNr rd, rs1, rs2``
     - Signed subtract & shift via  register
   * - 00
     - imm[4:0]
     - src2
     - src1
     - 111
     - dest
     - ``p.subRN rd, rs1, rs2, ls3``
     - Unsigned subtract & round & shift via ``ls3`` immediate
   * - 01
     - 00000
     - src2
     - src1
     - 111
     - dest
     - ``p.subRNr rd, rs1, rs2``
     - Unsigned subtract & round & shift via register
   * - 10
     - imm[4:0]
     - src2
     - src1
     - 111
     - dest
     - ``p.subuNr rd, rs1, rs2, ls3``
     - Signed subtract & round & shift via ``ls3`` immediate
   * - 11
     - 00000
     - src2
     - src1
     - 111
     - dest
     - ``p.subuRNr rd, rs1, rs2``
     - Signed subtract & round & shift via register

.. todo::
   All of these ADD/SUB commands to be elaborated ...


OPCODE = 0x5B
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Description
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RTL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: systemverilog
   :linenos:

   OPCODE_PULP_OP: begin  // PULP specific ALU instructions with three source operands
      regfile_alu_we = 1'b1;
      rega_used_o    = 1'b1;
      regb_used_o    = 1'b1;

      case (instr_rdata_i[13:12])
        2'b00: begin // Multiply with subword selection
           alu_en_o           = 1'b0;

           mult_sel_subword_o = instr_rdata_i[30];
           mult_signed_mode_o = {2{instr_rdata_i[31]}};

           mult_imm_mux_o = MIMM_S3;
           regc_mux_o     = REGC_ZERO;
           mult_int_en_o  = 1'b1;

           if (instr_rdata_i[14])
             mult_operator_o = MUL_IR;
           else
             mult_operator_o = MUL_I;

           `USE_APU_INT_MULT
        end

        2'b01: begin // MAC with subword selection
           alu_en_o           = 1'b0;

           mult_sel_subword_o = instr_rdata_i[30];
           mult_signed_mode_o = {2{instr_rdata_i[31]}};

           regc_used_o     = 1'b1;
           regc_mux_o      = REGC_RD;
           mult_imm_mux_o  = MIMM_S3;
           mult_int_en_o   = 1'b1;

           if (instr_rdata_i[14])
             mult_operator_o = MUL_IR;
           else
             mult_operator_o = MUL_I;

           `USE_APU_INT_MULT
        end

        2'b10: begin
           // ADD with normalization and rounding
           // Decide between using unsigned and rounding, and combinations thereof
           case ({instr_rdata_i[31],instr_rdata_i[14]})
             2'b00: alu_operator_o = ALU_ADD;
             2'b01: alu_operator_o = ALU_ADDR;
             2'b10: alu_operator_o = ALU_ADDU;
             2'b11: alu_operator_o = ALU_ADDUR;
           endcase

           bmask_a_mux_o = BMASK_A_ZERO;
           bmask_b_mux_o = BMASK_B_S3;

           if (instr_rdata_i[30]) begin
              // Register variant
              regc_used_o            = 1'b1;
              regc_mux_o             = REGC_RD;
              alu_bmask_b_mux_sel_o  = BMASK_B_REG;
              alu_op_a_mux_sel_o     = OP_A_REGC_OR_FWD;
              alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;
           end
        end

        2'b11: begin
           // SUB with normalization and rounding
           // Decide between using unsigned and rounding, and combinations thereof
           case ({instr_rdata_i[31],instr_rdata_i[14]})
             2'b00: alu_operator_o = ALU_SUB;
             2'b01: alu_operator_o = ALU_SUBR;
             2'b10: alu_operator_o = ALU_SUBU;
             2'b11: alu_operator_o = ALU_SUBUR;
           endcase

           bmask_a_mux_o = BMASK_A_ZERO;
           bmask_b_mux_o = BMASK_B_S3;

           if (instr_rdata_i[30]) begin
              // Register variant
              regc_used_o            = 1'b1;
              regc_mux_o             = REGC_RD;
              alu_bmask_b_mux_sel_o  = BMASK_B_REG;
              alu_op_a_mux_sel_o     = OP_A_REGC_OR_FWD;
              alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;
           end
        end
      endcase
   end


***************************************************************************
Vectorial instructions
***************************************************************************

ALU vectorial commands encoded as R-type or I-type intrsuction:

+--+-------+--+--+--+---+--+--+---+--+--+-----+--+--+-------+-+-+------+-+
|31| ...   |26|25|24|...|20|19|...|15|14| ... |12|11| ...   |7|6| ...  |0|
+--+-------+--+--+--+---+--+--+---+--+--+-----+--+--+-------+-+-+------+-+

+--+-------+--+--+--+---+--+--+---+--+--+-----+--+--+-------+-+-+------+-+
|``funct7``      | ``rs2`` | ``rs1`` | ``funct3``|   ``rd``   |``opcode``|
+==========+==+==+=========+=========+===========+============+==========+
|``funct5``|C |0 | ``src2``| ``src1``| ``mode``  |   ``rd``   |``opcode``|
+----------+--+--+---------+---------+-----------+------------+----------+

|

+--+-------+--+--+------+--+--+---+--+--+-----+--+--+-------+-+-+------+-+
|31| ...   |26|25|...   |20|19|...|15|14| ... |12|11| ...   |7|6| ...  |0|
+--+-------+--+--+------+--+--+---+--+--+-----+--+--+-------+-+-+------+-+

+--+-------+--+--+------+--+--+---+--+--+-----+--+--+-------+-+-+------+-+
| ``imm[11:0]``            | ``rs1`` | ``funct3``|   ``rd``   |``opcode``|
+==========+==+============+=========+===========+============+==========+
|``funct5``|C |``imm[5:0]``| ``src1``| ``mode``  |   ``rd``   |``opcode``|
+----------+--+------------+---------+-----------+------------+----------+


``funct3`` controls the mode the vectors are treated:

* ``funct3[2]`` - Scalar replication: Y/N
* ``funct3[1]`` - ``src2`` register required: N/Y
* ``funct3[0]`` - Vector width: 8/16


``imm[11:0]`` & ``funct7`` fields of the R & I instruction types, divided a bit differently for the vectoric commands:

* ``C`` - determines if the command is a comparison: Y/N
* ``funct5`` - chooses the vector command

All ALU vectorial commands are summarized in the following 2 tables, for I & R types:

.. list-table:: ALU vectorial R-type commands summary
   :widths: 5 5 5 5 5 5 5 15 60
   :header-rows: 1

   * - ``funct5``
     - ``C``
     - ``0``
     - ``rs2``
     - ``rs1``
     - ``funct3``
     - ``rd``
     - Assembly mnemonic
     - Description
   * - 00000
     - 1
     - 0
     - src2
     - src1
     - 000
     - dest
     - ``pv.cmpeq.h rd, rs1, rs2``
     - ALU compare equal of lower 16 bit ``RF[rs1]`` vector `vs.` lower 16 bit ``RF[rs2]`` vector
   * - 00000
     - 1
     - 0
     - src2
     - src1
     - 001
     - dest
     - ``pv.cmpeq.b rd, rs1, rs2``
     - ALU compare equal of lower 8 bit ``RF[rs1]`` vector `vs.` lower 8 bit ``RF[rs2]`` vector
   * - 00000
     - 1
     - 0
     - src2
     - src1
     - 100
     - dest
     - ``pv.cmpeq.sc.b rd, rs1, rs2``
     - ALU compare equal of lower 16 bit ``RF[rs1]`` vector `vs.` ??? bit ``RF[rs2]`` vector

.. todo::
   All vector commands (A LOT) to be elaborated ...


OPCODE = 0x57
---------------------------------------------------------------------------

RTL
---------------------------------------------------------------------------

.. code-block:: systemverilog
   :linenos:

   OPCODE_VECOP: begin
      regfile_alu_we      = 1'b1;
      rega_used_o         = 1'b1;
      imm_b_mux_sel_o     = IMMB_VS;

      // Vector size
      if (instr_rdata_i[12]) begin
         alu_vec_mode_o  = VEC_MODE8;
         mult_operator_o = MUL_DOT8;
      end else begin
         alu_vec_mode_o = VEC_MODE16;
         mult_operator_o = MUL_DOT16;
      end

      // Distinguish normal vector, sc and sci modes
      if (instr_rdata_i[14]) begin
         scalar_replication_o = 1'b1;

         if (instr_rdata_i[13]) begin
            // Immediate scalar replication, .sci
            alu_op_b_mux_sel_o = OP_B_IMM;
         end else begin
            // Register scalar replication, .sc
            regb_used_o = 1'b1;
         end
      end else begin
         // Normal register use
         regb_used_o = 1'b1;
      end

      // Now decode the instruction
      unique case (instr_rdata_i[31:26])
        6'b00000_0: begin alu_operator_o = ALU_ADD;  imm_b_mux_sel_o = IMMB_VS;  end // pv.add
        6'b00001_0: begin alu_operator_o = ALU_SUB;  imm_b_mux_sel_o = IMMB_VS;  end // pv.sub
        6'b00010_0: begin alu_operator_o = ALU_ADD;  imm_b_mux_sel_o = IMMB_VS; bmask_b_mux_o = BMASK_B_ONE;  end // pv.avg
        6'b00011_0: begin alu_operator_o = ALU_ADDU; imm_b_mux_sel_o = IMMB_VU; bmask_b_mux_o = BMASK_B_ONE;  end // pv.avgu
        6'b00100_0: begin alu_operator_o = ALU_MIN;  imm_b_mux_sel_o = IMMB_VS;  end // pv.min
        6'b00101_0: begin alu_operator_o = ALU_MINU; imm_b_mux_sel_o = IMMB_VU;  end // pv.minu
        6'b00110_0: begin alu_operator_o = ALU_MAX;  imm_b_mux_sel_o = IMMB_VS;  end // pv.max
        6'b00111_0: begin alu_operator_o = ALU_MAXU; imm_b_mux_sel_o = IMMB_VU;  end // pv.maxu
        6'b01000_0: begin alu_operator_o = ALU_SRL;  imm_b_mux_sel_o = IMMB_VS;  end // pv.srl
        6'b01001_0: begin alu_operator_o = ALU_SRA;  imm_b_mux_sel_o = IMMB_VS;  end // pv.sra
        6'b01010_0: begin alu_operator_o = ALU_SLL;  imm_b_mux_sel_o = IMMB_VS;  end // pv.sll
        6'b01011_0: begin alu_operator_o = ALU_OR;   imm_b_mux_sel_o = IMMB_VS;  end // pv.or
        6'b01100_0: begin alu_operator_o = ALU_XOR;  imm_b_mux_sel_o = IMMB_VS;  end // pv.xor
        6'b01101_0: begin alu_operator_o = ALU_AND;  imm_b_mux_sel_o = IMMB_VS;  end // pv.and
        6'b01110_0: begin alu_operator_o = ALU_ABS;  imm_b_mux_sel_o = IMMB_VS;  end // pv.abs

        // Shuffle/pack
        6'b11101_0,       // pv.shuffleI1
        6'b11110_0,       // pv.shuffleI2
        6'b11111_0,       // pv.shuffleI3
        6'b11000_0: begin // pv.shuffle, pv.shuffleI0
             alu_operator_o       = ALU_SHUF;
             imm_b_mux_sel_o      = IMMB_SHUF;
             regb_used_o          = 1'b1;
             scalar_replication_o = 1'b0;
        end

        6'b11001_0: begin // pv.shuffle2
           alu_operator_o       = ALU_SHUF2;
           regb_used_o          = 1'b1;
           regc_used_o          = 1'b1;
           regc_mux_o           = REGC_RD;
           scalar_replication_o = 1'b0;
        end

        6'b11010_0: begin // pv.pack
           alu_operator_o = ALU_PCKLO;
           regb_used_o    = 1'b1;
        end

        6'b11011_0: begin // pv.packhi
           alu_operator_o = ALU_PCKHI;
           regb_used_o    = 1'b1;
           regc_used_o    = 1'b1;
           regc_mux_o     = REGC_RD;
        end

        6'b11100_0: begin // pv.packlo
           alu_operator_o = ALU_PCKLO;
           regb_used_o    = 1'b1;
           regc_used_o    = 1'b1;
           regc_mux_o     = REGC_RD;
        end

        6'b01111_0: begin // pv.extract
           alu_operator_o = ALU_EXTS;
        end

        6'b10010_0: begin // pv.extractu
           alu_operator_o = ALU_EXT;
        end

        6'b10110_0: begin // pv.insert
           alu_operator_o     = ALU_INS;
           regc_used_o        = 1'b1;
           regc_mux_o         = REGC_RD;
           alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;
        end

        6'b10000_0: begin // pv.dotup
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b00;
           `USE_APU_DSP_MULT
        end

        6'b10001_0: begin // pv.dotusp
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b01;
           `USE_APU_DSP_MULT
        end

        6'b10011_0: begin // pv.dotsp
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b11;
           `USE_APU_DSP_MULT
        end

        6'b10100_0: begin // pv.sdotup
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b00;
           regc_used_o       = 1'b1;
           regc_mux_o        = REGC_RD;
           `USE_APU_DSP_MULT
        end

        6'b10101_0: begin // pv.sdotusp
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b01;
           regc_used_o       = 1'b1;
           regc_mux_o        = REGC_RD;
           `USE_APU_DSP_MULT
        end

        6'b10111_0: begin // pv.sdotsp
           alu_en_o          = 1'b0;
           mult_dot_en_o     = 1'b1;
           mult_dot_signed_o = 2'b11;
           regc_used_o       = 1'b1;
           regc_mux_o        = REGC_RD;
           `USE_APU_DSP_MULT
        end

        // Comparisons, always have bit 26 set
        6'b00000_1: begin alu_operator_o = ALU_EQ;  imm_b_mux_sel_o     = IMMB_VS; end // pv.cmpeq
        6'b00001_1: begin alu_operator_o = ALU_NE;  imm_b_mux_sel_o     = IMMB_VS; end // pv.cmpne
        6'b00010_1: begin alu_operator_o = ALU_GTS; imm_b_mux_sel_o     = IMMB_VS; end // pv.cmpgt
        6'b00011_1: begin alu_operator_o = ALU_GES; imm_b_mux_sel_o     = IMMB_VS; end // pv.cmpge
        6'b00100_1: begin alu_operator_o = ALU_LTS; imm_b_mux_sel_o     = IMMB_VS; end // pv.cmplt
        6'b00101_1: begin alu_operator_o = ALU_LES; imm_b_mux_sel_o     = IMMB_VS; end // pv.cmple
        6'b00110_1: begin alu_operator_o = ALU_GTU; imm_b_mux_sel_o     = IMMB_VU; end // pv.cmpgtu
        6'b00111_1: begin alu_operator_o = ALU_GEU; imm_b_mux_sel_o     = IMMB_VU; end // pv.cmpgeu
        6'b01000_1: begin alu_operator_o = ALU_LTU; imm_b_mux_sel_o     = IMMB_VU; end // pv.cmpltu
        6'b01001_1: begin alu_operator_o = ALU_LEU; imm_b_mux_sel_o     = IMMB_VU; end // pv.cmpleu

        default: illegal_insn_o = 1'b1;
      endcase
   end


***************************************************************************
Floating point (FP) operations
***************************************************************************

N/A under this particular release.


***************************************************************************
System
***************************************************************************

System special commands encoded as I-type intrsuction with these fields:

+--+-------------+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
|31| ...         |20|19| ...   |15|14| ...  |12|11|...|7|6| ...    |0|
+--+-------------+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
| ``imm[31:25]``    |   ``rs1``   | ``funct3`` | ``rd`` | ``opcode`` |
+-------------------+-------------+------------+--------+------------+
|      cmd_sel1     |     src     |  cmd_sel0  |  dest  |    0x73    |
+-------------------+-------------+------------+--------+------------+

All sytem special commands are summarized in the following table:

.. list-table:: System special commands summary
   :widths: 10 5 5 5 15 60
   :header-rows: 1

   * - ``imm[31:25]``
     - ``rs1``
     - ``funct3``
     - ``rd``
     - Assembly mnemonic
     - Description
   * - 0x000
     - N/A
     - 000
     - N/A
     - ``ecall``
     - Environment (system) call
   * - 0x001
     - N/A
     - 000
     - N/A
     - ``ebreak``
     - Debuger trap
   * - 0x002
     - N/A
     - 000
     - N/A
     - ``uret``
     - ???
   * - 0x105
     - N/A
     - 000
     - N/A
     - ``wfi``
     - Flush pipeline
   * - 0x302
     - N/A
     - 000
     - N/A
     - ``mret``
     - ???
   * - imm[31:20]
     - src
     - 001
     - dest
     - ``???``
     - CSR write by immediate
   * - imm[31:20]
     - src
     - 101
     - dest
     - ``???``
     - CSR write by register
   * - imm[31:20]
     - src
     - 010
     - dest
     - ``???``
     - CSR set by immediate
   * - imm[31:20]
     - src
     - 110
     - dest
     - ``???``
     - CSR set by register
   * - imm[31:20]
     - src
     - 011
     - dest
     - ``???``
     - CSR clear by immediate
   * - imm[31:20]
     - src
     - 111
     - dest
     - ``???``
     - CSR clear by register
   * - 0x000
     - N/A
     - Not \*00
     - N/A
     - ``xstatus``
     - Some status (Conditional for sufficient privilege)
   * - 0x300
     - N/A
     - Not \*00
     - N/A
     - ``xstatus``
     - Some status (Conditional for sufficient privilege)
   * - ``*``
     - N/A
     - 100
     - N/A
     - N/A
     - No access to CSR due to privelege exception
   * - imm[29:28] > Privilege level
     - N/A
     - Not 000
     - N/A
     - N/A
     - No access to CSR due to privelege exception

.. todo::
   All of these system commands to be elaborated ...

OPCODE = 0x73
---------------------------------------------------------------------------

Description
---------------------------------------------------------------------------

.. todo::
   To be described ...

***************************************************************************
H/W loop
***************************************************************************

H/W loop commands encoded as I-type intrsuction with these fields:

+--+-------------+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
|31| ...         |20|19| ...   |15|14| ...  |12|11|...|7|6| ...    |0|
+--+-------------+--+--+-------+--+--+------+--+--+---+-+-+--------+-+
| ``imm[31:25]``    |   ``rs1``   | ``funct3`` | ``rd`` | ``opcode`` |
+-------------------+-------------+------------+------+-+------------+
|      offset       |     src     |    cmd     | 0000 |L|    0x7B    |
+-------------------+-------------+------------+------+-+------------+

``L`` is a loop index, where loop #0 has higher priority than #1.

All H/W loop commands are summarized in the following table:

.. list-table:: H/W loop commands summary
   :widths: 5 5 2 2 1 10 75
   :header-rows: 1

   * - ``imm[31:25]``
     - ``rs1``
     - ``funct3``
     - ``0000``
     - ``L``
     - Assembly mnemonic
     - Description
   * - immL[11:0]
     - 0x0
     - 000
     - 0000
     - L
     - ``lp.starti L, uimmL``
     - Loop start address immediate offset realtively to PC
   * - immL[11:0]
     - 0x0
     - 001
     - 0000
     - L
     - ``lp.endi L, uimmL``
     - Loop end address immediate offset realtively to PC
   * - 0x000
     - src
     - 010
     - 0000
     - L
     - ``lp.count L, rs1``
     - Set loop counter to ``RF[rs1]``
   * - immL[11:0]
     - src
     - 011
     - 0000
     - L
     - ``lp.counti L, uimmL``
     - Set loop counter to immediate
   * - immL[11:0]
     - src
     - 100
     - 0000
     - L
     - ``lp.setup L, rs1, uimmL``
     - Set up a complete loop definition (via register): start, end & count
   * - immL[11:0]
     - immS[4:0]
     - 101
     - 0000
     - L
     - ``lp.setupi L, uimmS, uimmL``
     - Set up a complete loop definition (via immediate): start, end & count
   * - \*
     - \*
     - 11*
     - 0000
     - L
     - N/A
     - Illegal instruction

.. todo::
   All of these H/W loop commands to be elaborated ...


RTL
---------------------------------------------------------------------------

.. code-block:: systemverilog
   :linenos:

   OPCODE_SYSTEM: begin
      if (instr_rdata_i[14:12] == 3'b000)
        begin
           // Non CSR related SYSTEM instructions
           unique case (instr_rdata_i[31:20])
             12'h000:  // ECALL
               begin
                  // Environment (system) call
                  ecall_insn_o  = 1'b1;
               end

             12'h001:  // ebreak
               begin
                  // Debugger trap
                  ebrk_insn_o = 1'b1;
               end

             12'h302:  // mret
               begin
                  illegal_insn_o = (PULP_SECURE) ? current_priv_lvl_i != PRIV_LVL_M : 1'b0;
                  mret_insn_o    = ~illegal_insn_o;
               end

             12'h002:  // uret
               begin
                  uret_insn_o   = (PULP_SECURE) ? 1'b1 : 1'b0;
               end

             12'h105:  // wfi
               begin
                  // Flush pipeline
                  pipe_flush_o = 1'b1;
               end

             default:
               begin
                  illegal_insn_o = 1'b1;
               end
           endcase
        end
      else
        begin
           // Instruction to read/modify CSR
           csr_access_o        = 1'b1;
           regfile_alu_we      = 1'b1;
           alu_op_b_mux_sel_o  = OP_B_IMM;
           imm_a_mux_sel_o     = IMMA_Z;
           imm_b_mux_sel_o     = IMMB_I;    // CSR address is encoded in I imm
           instr_multicycle_o  = 1'b1;

           if (instr_rdata_i[14] == 1'b1) begin
              // rs1 field is used as immediate
              alu_op_a_mux_sel_o = OP_A_IMM;
           end else begin
              rega_used_o        = 1'b1;
              alu_op_a_mux_sel_o = OP_A_REGA_OR_FWD;
           end

           unique case (instr_rdata_i[13:12])
             2'b01:   csr_op   = CSR_OP_WRITE;
             2'b10:   csr_op   = CSR_OP_SET;
             2'b11:   csr_op   = CSR_OP_CLEAR;
             default: csr_illegal = 1'b1;
           endcase

           if (instr_rdata_i[29:28] > current_priv_lvl_i) begin
              // No access to higher privilege CSR
              csr_illegal = 1'b1;
           end

           if(~csr_illegal)
             if (instr_rdata_i[31:20] == 12'h300 || instr_rdata_i[31:20] == 12'h000)
               // Access to xstatus
               csr_status_o = 1'b1;

           illegal_insn_o = csr_illegal;
        end
   end



OPCODE = 0x7B
---------------------------------------------------------------------------

Description
---------------------------------------------------------------------------

RTL
---------------------------------------------------------------------------

.. code-block:: systemverilog
   :linenos:

   OPCODE_HWLOOP: begin
      hwloop_target_mux_sel_o = 1'b0;

      unique case (instr_rdata_i[14:12])
        3'b000: begin
           // lp.starti: set start address to PC + I-type immediate
           hwloop_we[0]           = 1'b1;
           hwloop_start_mux_sel_o = 1'b0;
        end

        3'b001: begin
           // lp.endi: set end address to PC + I-type immediate
           hwloop_we[1]         = 1'b1;
        end

        3'b010: begin
           // lp.count: initialize counter from rs1
           hwloop_we[2]         = 1'b1;
           hwloop_cnt_mux_sel_o = 1'b1;
           rega_used_o          = 1'b1;
        end

        3'b011: begin
           // lp.counti: initialize counter from I-type immediate
           hwloop_we[2]         = 1'b1;
           hwloop_cnt_mux_sel_o = 1'b0;
        end

        3'b100: begin
           // lp.setup: initialize counter from rs1, set start address to
           // Next instruction and end address to PC + I-type immediate
           hwloop_we              = 3'b111;
           hwloop_start_mux_sel_o = 1'b1;
           hwloop_cnt_mux_sel_o   = 1'b1;
           rega_used_o            = 1'b1;
        end

        3'b101: begin
           // lp.setupi: initialize counter from immediate, set start address to
           // Next instruction and end address to PC + I-type immediate
           hwloop_we               = 3'b111;
           hwloop_target_mux_sel_o = 1'b1;
           hwloop_start_mux_sel_o  = 1'b1;
           hwloop_cnt_mux_sel_o    = 1'b0;
        end

        default: begin
           illegal_insn_o = 1'b1;
        end
      endcase
   end

